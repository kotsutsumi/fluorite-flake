import { GraphQLError } from 'graphql';
import { auth } from '../auth';
import { db } from '../db';
import type { Resolvers } from '../../generated/graphql';

// Context type for resolvers
export interface GraphQLContext {
  user?: {
    id: string;
    email: string;
    role: string;
  };
  session?: any;
}

// Helper function to check authentication
function requireAuth(context: GraphQLContext) {
  if (!context.user) {
    throw new GraphQLError('Authentication required', {
      extensions: {
        code: 'UNAUTHENTICATED',
      },
    });
  }
  return context.user;
}

// Helper function to check organization membership
async function requireOrgMembership(userId: string, organizationId: string, minRole?: string) {
  const membership = await db.organizationMember.findFirst({
    where: {
      userId,
      organizationId,
    },
  });

  if (!membership) {
    throw new GraphQLError('Not a member of this organization', {
      extensions: {
        code: 'FORBIDDEN',
      },
    });
  }

  // Add role checking logic here if needed
  return membership;
}

export const resolvers: Resolvers<GraphQLContext> = {
  Query: {
    // User queries
    me: async (_, __, context) => {
      const user = requireAuth(context);
      return db.user.findUnique({
        where: { id: user.id },
        include: {
          profile: true,
          organizations: {
            include: {
              organization: true,
            },
          },
        },
      });
    },

    user: async (_, { id }, context) => {
      requireAuth(context);
      const user = await db.user.findUnique({
        where: { id },
        include: {
          profile: true,
          organizations: {
            include: {
              organization: true,
            },
          },
        },
      });

      if (!user) {
        throw new GraphQLError('User not found', {
          extensions: {
            code: 'NOT_FOUND',
          },
        });
      }

      return user;
    },

    users: async (_, { limit = 10, offset = 0 }, context) => {
      const user = requireAuth(context);

      // Check if user is admin
      if (user.role !== 'ADMIN') {
        throw new GraphQLError('Admin access required', {
          extensions: {
            code: 'FORBIDDEN',
          },
        });
      }

      const [items, total] = await Promise.all([
        db.user.findMany({
          skip: offset,
          take: limit,
          include: {
            profile: true,
          },
        }),
        db.user.count(),
      ]);

      return {
        items,
        total,
        hasMore: offset + limit < total,
      };
    },

    // Organization queries
    organization: async (_, { id }, context) => {
      requireAuth(context);
      const organization = await db.organization.findUnique({
        where: { id },
        include: {
          owner: true,
          members: {
            include: {
              user: true,
            },
          },
          settings: true,
        },
      });

      if (!organization) {
        throw new GraphQLError('Organization not found', {
          extensions: {
            code: 'NOT_FOUND',
          },
        });
      }

      return organization;
    },

    organizations: async (_, { limit = 10, offset = 0 }, context) => {
      requireAuth(context);

      const [items, total] = await Promise.all([
        db.organization.findMany({
          skip: offset,
          take: limit,
          include: {
            owner: true,
            members: {
              include: {
                user: true,
              },
            },
          },
        }),
        db.organization.count(),
      ]);

      return {
        items,
        total,
        hasMore: offset + limit < total,
      };
    },

    myOrganizations: async (_, __, context) => {
      const user = requireAuth(context);

      const memberships = await db.organizationMember.findMany({
        where: { userId: user.id },
        include: {
          organization: {
            include: {
              owner: true,
              members: {
                include: {
                  user: true,
                },
              },
            },
          },
        },
      });

      return memberships.map(m => m.organization);
    },

    // Profile queries
    myProfile: async (_, __, context) => {
      const user = requireAuth(context);
      return db.profile.findUnique({
        where: { userId: user.id },
        include: {
          user: true,
        },
      });
    },

    profile: async (_, { userId }, context) => {
      requireAuth(context);
      return db.profile.findUnique({
        where: { userId },
        include: {
          user: true,
        },
      });
    },

    // Dashboard stats
    dashboardStats: async (_, __, context) => {
      const user = requireAuth(context);

      const [totalUsers, totalOrganizations, activeUsers] = await Promise.all([
        db.user.count(),
        db.organization.count(),
        db.user.count({
          where: {
            lastActiveAt: {
              gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // Last 7 days
            },
          },
        }),
      ]);

      const recentActivity = await db.activity.findMany({
        take: 10,
        orderBy: {
          timestamp: 'desc',
        },
        include: {
          user: true,
        },
      });

      return {
        totalUsers,
        totalOrganizations,
        activeUsers,
        recentActivity,
      };
    },
  },

  Mutation: {
    // Authentication mutations
    login: async (_, { input }, context) => {
      const { email, password, rememberMe } = input;

      // Validate credentials using BetterAuth
      const result = await auth.signIn({
        email,
        password,
      });

      if (!result.user) {
        throw new GraphQLError('Invalid credentials', {
          extensions: {
            code: 'UNAUTHORIZED',
          },
        });
      }

      // Generate tokens
      const accessToken = await auth.createAccessToken(result.user.id);
      const refreshToken = await auth.createRefreshToken(result.user.id);

      return {
        user: result.user,
        accessToken,
        refreshToken,
        expiresIn: rememberMe ? 30 * 24 * 60 * 60 : 24 * 60 * 60, // 30 days or 1 day
      };
    },

    register: async (_, { input }) => {
      const { email, password, name, organizationName } = input;

      // Check if user exists
      const existingUser = await db.user.findUnique({
        where: { email },
      });

      if (existingUser) {
        throw new GraphQLError('Email already in use', {
          extensions: {
            code: 'CONFLICT',
          },
        });
      }

      // Create user using BetterAuth
      const result = await auth.signUp({
        email,
        password,
        name,
      });

      if (!result.user) {
        throw new GraphQLError('Registration failed', {
          extensions: {
            code: 'INTERNAL_ERROR',
          },
        });
      }

      // Create profile
      await db.profile.create({
        data: {
          userId: result.user.id,
          displayName: name,
        },
      });

      // Create organization if specified
      if (organizationName) {
        const organization = await db.organization.create({
          data: {
            name: organizationName,
            slug: organizationName.toLowerCase().replace(/\s+/g, '-'),
            ownerId: result.user.id,
          },
        });

        // Add user as owner
        await db.organizationMember.create({
          data: {
            userId: result.user.id,
            organizationId: organization.id,
            role: 'OWNER',
          },
        });
      }

      // Generate tokens
      const accessToken = await auth.createAccessToken(result.user.id);
      const refreshToken = await auth.createRefreshToken(result.user.id);

      return {
        user: result.user,
        accessToken,
        refreshToken,
        expiresIn: 24 * 60 * 60, // 1 day
      };
    },

    logout: async (_, __, context) => {
      const user = requireAuth(context);

      // Invalidate session
      await auth.signOut(context.session);

      return true;
    },

    refreshToken: async (_, { refreshToken }) => {
      // Validate refresh token
      const userId = await auth.validateRefreshToken(refreshToken);

      if (!userId) {
        throw new GraphQLError('Invalid refresh token', {
          extensions: {
            code: 'UNAUTHORIZED',
          },
        });
      }

      const user = await db.user.findUnique({
        where: { id: userId },
      });

      if (!user) {
        throw new GraphQLError('User not found', {
          extensions: {
            code: 'NOT_FOUND',
          },
        });
      }

      // Generate new tokens
      const newAccessToken = await auth.createAccessToken(user.id);
      const newRefreshToken = await auth.createRefreshToken(user.id);

      return {
        user,
        accessToken: newAccessToken,
        refreshToken: newRefreshToken,
        expiresIn: 24 * 60 * 60, // 1 day
      };
    },

    // User mutations
    updateUser: async (_, { id, input }, context) => {
      const currentUser = requireAuth(context);

      // Check permissions
      if (currentUser.id !== id && currentUser.role !== 'ADMIN') {
        throw new GraphQLError('Permission denied', {
          extensions: {
            code: 'FORBIDDEN',
          },
        });
      }

      const user = await db.user.update({
        where: { id },
        data: input,
        include: {
          profile: true,
        },
      });

      return user;
    },

    deleteUser: async (_, { id }, context) => {
      const currentUser = requireAuth(context);

      // Only admins can delete users
      if (currentUser.role !== 'ADMIN') {
        throw new GraphQLError('Admin access required', {
          extensions: {
            code: 'FORBIDDEN',
          },
        });
      }

      await db.user.delete({
        where: { id },
      });

      return true;
    },

    // Organization mutations
    createOrganization: async (_, { input }, context) => {
      const user = requireAuth(context);

      const organization = await db.organization.create({
        data: {
          ...input,
          slug: input.slug || input.name.toLowerCase().replace(/\s+/g, '-'),
          ownerId: user.id,
          settings: {
            create: {
              allowInvites: true,
              requireApproval: false,
            },
          },
        },
        include: {
          owner: true,
          members: {
            include: {
              user: true,
            },
          },
          settings: true,
        },
      });

      // Add creator as owner
      await db.organizationMember.create({
        data: {
          userId: user.id,
          organizationId: organization.id,
          role: 'OWNER',
        },
      });

      return organization;
    },

    updateOrganization: async (_, { id, input }, context) => {
      const user = requireAuth(context);

      // Check if user is admin or owner of the organization
      const membership = await requireOrgMembership(user.id, id, 'ADMIN');

      const organization = await db.organization.update({
        where: { id },
        data: {
          ...input,
          settings: input.settings ? {
            update: input.settings,
          } : undefined,
        },
        include: {
          owner: true,
          members: {
            include: {
              user: true,
            },
          },
          settings: true,
        },
      });

      return organization;
    },

    deleteOrganization: async (_, { id }, context) => {
      const user = requireAuth(context);

      // Check if user is owner of the organization
      const organization = await db.organization.findUnique({
        where: { id },
      });

      if (!organization) {
        throw new GraphQLError('Organization not found', {
          extensions: {
            code: 'NOT_FOUND',
          },
        });
      }

      if (organization.ownerId !== user.id) {
        throw new GraphQLError('Only the owner can delete the organization', {
          extensions: {
            code: 'FORBIDDEN',
          },
        });
      }

      await db.organization.delete({
        where: { id },
      });

      return true;
    },

    // Profile mutations
    updateProfile: async (_, { input }, context) => {
      const user = requireAuth(context);

      const profile = await db.profile.upsert({
        where: { userId: user.id },
        update: input,
        create: {
          userId: user.id,
          ...input,
        },
        include: {
          user: true,
        },
      });

      return profile;
    },

    uploadAvatar: async (_, { file }, context) => {
      const user = requireAuth(context);

      // Handle file upload (implementation depends on storage provider)
      // This is a placeholder implementation
      const avatarUrl = `/uploads/avatars/${user.id}-${Date.now()}.jpg`;

      await db.profile.update({
        where: { userId: user.id },
        data: {
          avatar: avatarUrl,
        },
      });

      return avatarUrl;
    },
  },

  // Field resolvers for nested types
  User: {
    profile: async (parent, _, context) => {
      if (parent.profile) return parent.profile;

      return db.profile.findUnique({
        where: { userId: parent.id },
      });
    },

    organizations: async (parent, _, context) => {
      if (parent.organizations) return parent.organizations;

      return db.organizationMember.findMany({
        where: { userId: parent.id },
        include: {
          organization: true,
        },
      });
    },
  },

  Organization: {
    owner: async (parent, _, context) => {
      if (parent.owner) return parent.owner;

      return db.user.findUnique({
        where: { id: parent.ownerId },
      });
    },

    members: async (parent, _, context) => {
      if (parent.members) return parent.members;

      return db.organizationMember.findMany({
        where: { organizationId: parent.id },
        include: {
          user: true,
        },
      });
    },

    settings: async (parent, _, context) => {
      if (parent.settings) return parent.settings;

      return db.organizationSettings.findUnique({
        where: { organizationId: parent.id },
      });
    },
  },

  Profile: {
    user: async (parent, _, context) => {
      if (parent.user) return parent.user;

      return db.user.findUnique({
        where: { id: parent.userId },
      });
    },
  },
};
/**
 * Shared utilities for file generation and template processing
 */

import path from 'node:path';
import fs from 'fs-extra';

/**
 * Write JSON configuration file with consistent formatting
 */
export async function writeConfigFile<T extends Record<string, unknown>>(
    filePath: string,
    config: T,
    options?: {
        spaces?: number;
        sortKeys?: boolean;
    }
): Promise<void> {
    let configToWrite = config;

    if (options?.sortKeys) {
        configToWrite = sortObjectKeys(config) as T;
    }

    await fs.ensureDir(path.dirname(filePath));
    await fs.writeJSON(filePath, configToWrite, {
        spaces: options?.spaces ?? 2,
    });
}

/**
 * Write TypeScript/JavaScript file with proper formatting
 */
export async function writeCodeFile(
    filePath: string,
    content: string,
    options?: {
        addHeader?: boolean;
        headerComment?: string;
    }
): Promise<void> {
    let finalContent = content;

    if (options?.addHeader) {
        const header =
            options.headerComment ??
            `/**\n * Generated by fluorite-flake\n * ${new Date().toISOString()}\n */\n\n`;
        finalContent = header + content;
    }

    await fs.ensureDir(path.dirname(filePath));
    await fs.writeFile(filePath, finalContent);
}

/**
 * Process template with variable substitution
 */
export function processTemplate(
    template: string,
    variables: Record<string, string | number | boolean>
): string {
    return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
        const value = variables[key];
        return value !== undefined ? String(value) : match;
    });
}

/**
 * Read template file and process variables
 */
export async function processTemplateFile(
    templatePath: string,
    variables: Record<string, string | number | boolean>,
    outputPath: string
): Promise<void> {
    const template = await fs.readFile(templatePath, 'utf-8');
    const processed = processTemplate(template, variables);
    await writeCodeFile(outputPath, processed);
}

/**
 * Merge package.json files
 */
export async function mergePackageJson(
    targetPath: string,
    additions: {
        dependencies?: Record<string, string>;
        devDependencies?: Record<string, string>;
        scripts?: Record<string, string>;
        [key: string]: unknown;
    }
): Promise<void> {
    const packageJsonPath = path.join(targetPath, 'package.json');
    const existingPackageJson = await fs.readJSON(packageJsonPath).catch(() => ({}));

    const merged = {
        ...existingPackageJson,
        ...additions,
        dependencies: {
            ...existingPackageJson.dependencies,
            ...additions.dependencies,
        },
        devDependencies: {
            ...existingPackageJson.devDependencies,
            ...additions.devDependencies,
        },
        scripts: {
            ...existingPackageJson.scripts,
            ...additions.scripts,
        },
    };

    await writeConfigFile(packageJsonPath, merged, { sortKeys: true });
}

/**
 * Generate environment file
 */
export async function writeEnvFile(
    projectPath: string,
    envVars: Record<string, string>,
    filename: '.env' | '.env.local' | '.env.example' = '.env.example'
): Promise<void> {
    const envContent = `${Object.entries(envVars)
        .map(([key, value]) => `${key}=${value}`)
        .join('\n')}\n`;

    await fs.writeFile(path.join(projectPath, filename), envContent);
}

/**
 * Generate gitignore file
 */
export async function writeGitIgnore(projectPath: string, patterns: string[]): Promise<void> {
    const gitignoreContent = `${patterns.join('\n')}\n`;
    await fs.writeFile(path.join(projectPath, '.gitignore'), gitignoreContent);
}

/**
 * Common gitignore patterns
 */
export const GITIGNORE_PATTERNS = {
    node: [
        'node_modules/',
        'npm-debug.log*',
        'yarn-debug.log*',
        'yarn-error.log*',
        '.npm',
        '.yarn-integrity',
    ],
    nextjs: ['.next/', 'out/', '*.tsbuildinfo', '.vercel'],
    env: ['.env', '.env.local', '.env.*.local'],
    build: ['build/', 'dist/', 'coverage/'],
    os: ['.DS_Store', 'Thumbs.db', '*.log'],
    tauri: ['src-tauri/target/', 'src-tauri/Cargo.lock'],
    flutter: [
        '*.lock',
        '.flutter-plugins',
        '.flutter-plugins-dependencies',
        '.packages',
        'build/',
        '.dart_tool/',
    ],
};

/**
 * Helper function to sort object keys recursively
 */
function sortObjectKeys<T>(obj: T): T {
    if (obj === null || typeof obj !== 'object' || Array.isArray(obj)) {
        return obj;
    }

    const sorted = {} as T;
    const keys = Object.keys(obj as Record<string, unknown>).sort();

    for (const key of keys) {
        const value = (obj as Record<string, unknown>)[key];
        (sorted as Record<string, unknown>)[key] = sortObjectKeys(value);
    }

    return sorted;
}

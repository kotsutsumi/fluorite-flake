/**
 * Vercel Blobè¨­å®šç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ©Ÿèƒ½
 */

import { isCancel, select, text } from "@clack/prompts";
import { getMessages } from "../../../i18n.js";
import {
    createBlobStore,
    createBlobToken,
    generateBlobStoreName,
    generateUniqueStoreName,
    listBlobStores,
} from "../../../utils/vercel-cli/blob-operations.js";
import type { BlobConfiguration, BlobStore } from "../../../utils/vercel-cli/blob-types.js";
import { BlobErrorCode, BlobOperationError } from "../../../utils/vercel-cli/blob-types.js";

/**
 * Blobè¨­å®šãƒ•ãƒ­ãƒ¼å…¨ä½“ã‚’å®Ÿè¡Œã™ã‚‹
 * @param projectName ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå
 * @returns Blobè¨­å®šï¼ˆç„¡åŠ¹åŒ–ã®å ´åˆã¯nullï¼‰
 */
export async function collectBlobConfiguration(projectName: string): Promise<BlobConfiguration | null> {
    const messages = getMessages();

    // Phase 1: Blobåˆ©ç”¨æ–¹å¼ã®é¸æŠï¼ˆ3æŠï¼‰
    const blobMode = (await select({
        message: messages.create.blob.setupPrompt,
        options: [
            { value: "new", label: messages.create.blob.modeNew },
            { value: "existing", label: messages.create.blob.modeExisting },
            { value: "none", label: messages.create.blob.modeNone },
        ],
    })) as "new" | "existing" | "none";

    if (isCancel(blobMode) || blobMode === "none") {
        return null;
    }

    if (blobMode === "existing") {
        const blobToken = await promptForToken();
        if (!blobToken) {
            console.log("Blobãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ã§ã™ã€‚Blobè¨­å®šã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚");
            return null;
        }

        try {
            const existingStore = await selectExistingStore(blobToken);

            // æ—¢å­˜ã‚¹ãƒˆã‚¢é¸æŠæ™‚ã¯æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è‡ªå‹•ç”Ÿæˆ
            let finalToken = blobToken;
            let tokenId: string | undefined;
            let tokenScope: string | undefined;
            let tokenExpiresAt: string | undefined;
            let isAutoGenerated = false;

            try {
                console.log(`ğŸ”‘ é¸æŠã•ã‚ŒãŸã‚¹ãƒˆã‚¢ç”¨ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è‡ªå‹•ç”Ÿæˆä¸­: ${existingStore.storeId}`);
                const tokenResult = await createBlobToken({
                    storeId: existingStore.storeId,
                    scope: "read_write",
                    tokenType: "user",
                });

                if (tokenResult.success) {
                    finalToken = tokenResult.token;
                    tokenId = tokenResult.tokenId;
                    tokenScope = tokenResult.scope;
                    tokenExpiresAt = tokenResult.expiresAt;
                    isAutoGenerated = true;
                    console.log(`âœ… æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è‡ªå‹•ç”Ÿæˆã—ã¾ã—ãŸ: ${tokenResult.tokenId}`);
                }
            } catch (tokenError) {
                console.warn("âš ï¸ æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚å…ƒã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã—ã¾ã™:", tokenError);
                // æ—¢å­˜ãƒˆãƒ¼ã‚¯ãƒ³ã§ç¶šè¡Œ
            }

            return {
                mode: "existing",
                enabled: true,
                token: finalToken,
                storeId: existingStore.storeId,
                storeName: existingStore.storeName,
                storeUrl: existingStore.storeUrl,
                tokenId,
                tokenScope,
                tokenExpiresAt,
                isAutoGenerated,
            };
        } catch (error) {
            console.error("æ—¢å­˜ã‚¹ãƒˆã‚¢é¸æŠã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:", error);

            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é¸æŠè‚¢ã‚’æç¤º
            const fallbackChoice = await select({
                message: "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã©ã†ã—ã¾ã™ã‹ï¼Ÿ",
                options: [
                    { value: "retry", label: "ã‚‚ã†ä¸€åº¦è©¦ã™" },
                    { value: "disable", label: "Blobæ©Ÿèƒ½ã‚’ç„¡åŠ¹ã«ã—ã¦ç¶šè¡Œ" },
                ],
            });

            if (fallbackChoice === "retry") {
                // å†å¸°çš„ã«å†è©¦è¡Œ
                return await collectBlobConfiguration(projectName);
            }

            return null;
        }
    }

    try {
        const newStore = await createNewStore(projectName);

        return {
            mode: "new",
            enabled: true,
            token: newStore.token || undefined,
            storeId: newStore.storeId,
            storeName: newStore.storeName,
            storeUrl: newStore.storeUrl,
            tokenId: newStore.tokenId,
            tokenScope: newStore.tokenScope,
            tokenExpiresAt: newStore.tokenExpiresAt,
            isAutoGenerated: newStore.isAutoGenerated,
        };
    } catch (error) {
        if (error instanceof BlobOperationError && error.code === BlobErrorCode.INVALID_TOKEN) {
            console.warn("Blobã‚¹ãƒˆã‚¢ã®ä½œæˆã«å¿…è¦ãªèªè¨¼æƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã‚‹ãŸã‚ã€Blobè¨­å®šã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚");

            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é¸æŠè‚¢ã‚’æç¤º
            const fallbackChoice = await select({
                message: "èªè¨¼ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã©ã†ã—ã¾ã™ã‹ï¼Ÿ",
                options: [
                    { value: "retry", label: "ã‚‚ã†ä¸€åº¦è©¦ã™" },
                    { value: "disable", label: "Blobæ©Ÿèƒ½ã‚’ç„¡åŠ¹ã«ã—ã¦ç¶šè¡Œ" },
                ],
            });

            if (fallbackChoice === "retry") {
                // å†å¸°çš„ã«å†è©¦è¡Œ
                return await collectBlobConfiguration(projectName);
            }

            return null;
        }

        // ãã®ä»–ã®ã‚¨ãƒ©ãƒ¼ã‚‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é¸æŠè‚¢ã‚’æç¤º
        console.error("ã‚¹ãƒˆã‚¢ä½œæˆã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:", error);

        const fallbackChoice = await select({
            message: "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã©ã†ã—ã¾ã™ã‹ï¼Ÿ",
            options: [
                { value: "retry", label: "ã‚‚ã†ä¸€åº¦è©¦ã™" },
                { value: "disable", label: "Blobæ©Ÿèƒ½ã‚’ç„¡åŠ¹ã«ã—ã¦ç¶šè¡Œ" },
            ],
        });

        if (fallbackChoice === "retry") {
            return await collectBlobConfiguration(projectName);
        }

        return null;
    }
}

/**
 * ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—æ–¹æ³•ã‚’æ¡ˆå†…ã™ã‚‹
 */
function showTokenAcquisitionGuide(): void {
    console.log("\nğŸ“‹ BLOB_READ_WRITE_TOKEN ã®å–å¾—æ–¹æ³•:");
    console.log("");
    console.log("ğŸŒ æ–¹æ³•1: Vercel ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ï¼ˆæ¨å¥¨ï¼‰");
    console.log("1. https://vercel.com/dashboard ã«ã‚¢ã‚¯ã‚»ã‚¹");
    console.log("2. Storage â†’ Create Database â†’ Blob ã‚’é¸æŠ");
    console.log("3. ã‚¹ãƒˆã‚¢åã¨ãƒªãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è¨­å®šã—ã¦ä½œæˆ");
    console.log("4. ä½œæˆã•ã‚ŒãŸBlobã‚¹ãƒˆã‚¢ã® Settings â†’ Environment Variables ã‹ã‚‰");
    console.log("   BLOB_READ_WRITE_TOKEN ã‚’ã‚³ãƒ”ãƒ¼");
    console.log("");
    console.log("âš¡ æ–¹æ³•2: Vercel CLIï¼ˆè¦èªè¨¼ï¼‰");
    console.log("1. vercel login  # Vercelã«ãƒ­ã‚°ã‚¤ãƒ³");
    console.log("2. vercel link   # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒªãƒ³ã‚¯");
    console.log("3. vercel blob create [ã‚¹ãƒˆã‚¢å]  # ã‚¹ãƒˆã‚¢ä½œæˆ");
    console.log("");
    console.log("ğŸ“ æœŸå¾…ã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³å½¢å¼:");
    console.log("   vercel_blob_rw_xxxxxxxxxxxxxxx");
    console.log("");
}

/**
 * Blobãƒˆãƒ¼ã‚¯ãƒ³ã®å…¥åŠ›ã¨æ¤œè¨¼ã‚’è¡Œã†
 * @returns æœ‰åŠ¹ãªãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«æ™‚ã¯nullï¼‰
 */
async function promptForToken(options: { message?: string; showGuide?: boolean } = {}): Promise<string | null> {
    const messages = getMessages();
    let attempts = 0;
    const maxAttempts = 3;
    const message = options.message ?? messages.create.blob.tokenPrompt;

    // åˆå›ã®ã¿ã‚¬ã‚¤ãƒ‰ã‚’è¡¨ç¤º
    if (options.showGuide !== false && attempts === 0) {
        showTokenAcquisitionGuide();
    }

    while (attempts < maxAttempts) {
        const token = await text({
            message,
            placeholder: "vercel_blob_rw_xxxxxxxxxxxxxxx",
            validate: (value: string) => {
                if (!value.trim()) {
                    return messages.create.blob.tokenRequired;
                }

                const trimmedToken = value.trim();
                // Vercel Blobãƒˆãƒ¼ã‚¯ãƒ³ã¯ `vercel_blob_rw_` ã¾ãŸã¯ `blob_rw_` ã§å§‹ã¾ã‚‹
                if (!(trimmedToken.startsWith("vercel_blob_rw_") || trimmedToken.startsWith("blob_rw_"))) {
                    return messages.create.blob.tokenInvalidFormat;
                }

                // Vercel Blobãƒˆãƒ¼ã‚¯ãƒ³ã®æœ€å°é•·ã‚’ç¾å®Ÿçš„ãªå€¤ã«èª¿æ•´ï¼ˆç´„50æ–‡å­—ä»¥ä¸Šï¼‰
                if (trimmedToken.length < 50) {
                    return messages.create.blob.tokenTooShort;
                }

                return;
            },
        });

        if (isCancel(token)) {
            console.warn("Blobãƒˆãƒ¼ã‚¯ãƒ³å…¥åŠ›ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚");
            return null;
        }

        if (typeof token === "string") {
            const trimmedToken = token.trim();
            console.log("ãƒˆãƒ¼ã‚¯ãƒ³å½¢å¼ã®ç¢ºèªãŒå®Œäº†ã—ã¾ã—ãŸã€‚");
            return trimmedToken;
        }

        attempts++;
        if (attempts < maxAttempts) {
            console.log(`å†è©¦è¡Œã—ã¦ãã ã•ã„ï¼ˆ${attempts}/${maxAttempts}ï¼‰`);
        }
    }

    console.log("æœ€å¤§è©¦è¡Œå›æ•°ã«é”ã—ã¾ã—ãŸã€‚");
    return null;
}

/**
 * æ–°è¦ã‚¹ãƒˆã‚¢ä½œæˆãƒ•ãƒ­ãƒ¼
 * @param projectName ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå
 * @returns ã‚¹ãƒˆã‚¢æƒ…å ±ï¼ˆç™ºè¡Œã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã‚’å«ã‚€ï¼‰
 */
async function createNewStore(projectName: string): Promise<{
    storeId: string;
    storeName: string;
    storeUrl: string;
    token: string;
    tokenId?: string;
    tokenScope?: string;
    tokenExpiresAt?: string;
    isAutoGenerated?: boolean;
}> {
    // èªè¨¼ãƒã‚§ãƒƒã‚¯: Vercel CLIã®ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ³ã‚’ç¢ºèª
    const existingStores: BlobStore[] = [];
    const requiresTokenForCreation = true; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ãƒˆãƒ¼ã‚¯ãƒ³ãŒå¿…è¦ã¨è¨­å®š

    console.log("èªè¨¼çŠ¶æ³ã‚’ç¢ºèªä¸­...");
    console.log("ğŸ” BLOB_READ_WRITE_TOKENãŒæä¾›ã•ã‚Œã¦ã„ã¾ã›ã‚“");
    console.log("ğŸ” èªè¨¼ãŒå¿…è¦ã§ã™ã€‚BLOB_READ_WRITE_TOKEN ã®å…¥åŠ›ãŒå¿…è¦ã§ã™ã€‚");

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ãƒˆã‚¢åã‚’ç”Ÿæˆ
    const baseName = generateBlobStoreName(projectName);
    const defaultName = generateUniqueStoreName(baseName, existingStores);

    // ã‚¹ãƒˆã‚¢åã®å…¥åŠ›
    const messages = getMessages();
    const storeNameInput = (await text({
        message: messages.create.blob.storeNamePrompt,
        initialValue: defaultName,
        validate: (value: string) => {
            if (!value.trim()) {
                return messages.create.blob.storeNameRequired;
            }

            const trimmed = value.trim();
            if (trimmed.length < 3 || trimmed.length > 32) {
                return "ã‚¹ãƒˆã‚¢åã¯3-32æ–‡å­—ã§å…¥åŠ›ã—ã¦ãã ã•ã„";
            }

            if (!/^[a-z0-9-]+$/.test(trimmed)) {
                return "ã‚¹ãƒˆã‚¢åã¯è‹±å°æ–‡å­—ã€æ•°å­—ã€ãƒã‚¤ãƒ•ãƒ³ã®ã¿ä½¿ç”¨å¯èƒ½ã§ã™";
            }

            return;
        },
    })) as string;

    const storeName = storeNameInput.trim();

    console.log("Blobã‚¹ãƒˆã‚¢ã‚’ä½œæˆä¸­...");

    let tokenForCreation: string | undefined;

    if (requiresTokenForCreation) {
        const initialToken = await promptForToken({
            message: "BLOB_READ_WRITE_TOKEN ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆæ–°è¦ä½œæˆã«ä½¿ç”¨ã—ã¾ã™ï¼‰ï¼š",
            showGuide: true,
        });

        if (!initialToken) {
            throw new BlobOperationError(
                "BLOB_READ_WRITE_TOKEN ã®å…¥åŠ›ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚",
                BlobErrorCode.INVALID_TOKEN
            );
        }

        tokenForCreation = initialToken.trim();
    }

    while (true) {
        try {
            const result = await createBlobStore({
                name: storeName,
                token: tokenForCreation,
            });

            console.log(`âœ… Blobã‚¹ãƒˆã‚¢ '${result.store.name}' ã‚’ä½œæˆã—ã¾ã—ãŸ`);

            const resolvedToken = result.token || tokenForCreation || "";

            // createBlobStore ã§è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã‹ã©ã†ã‹ã‚’åˆ¤å®š
            const isAutoGenerated = !tokenForCreation && !!result.token;

            return {
                storeId: result.store.id,
                storeName: result.store.name,
                storeUrl: result.store.url,
                token: resolvedToken,
                tokenId: undefined, // createBlobStore ã§ã¯ tokenId ã¯è¿”ã•ã‚Œãªã„
                tokenScope: isAutoGenerated ? "read_write" : undefined,
                tokenExpiresAt: undefined,
                isAutoGenerated,
            };
        } catch (error) {
            if (error instanceof BlobOperationError && error.code === BlobErrorCode.INVALID_TOKEN) {
                console.warn("æä¾›ã•ã‚ŒãŸèªè¨¼æƒ…å ±ã§ Blob ã‚¹ãƒˆã‚¢ã‚’ä½œæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚å†å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");

                const retryToken = await promptForToken({
                    message: "BLOB_READ_WRITE_TOKEN ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆæ–°è¦ä½œæˆã«ä½¿ç”¨ã—ã¾ã™ï¼‰ï¼š",
                    showGuide: false, // å†è©¦è¡Œæ™‚ã¯ã‚¬ã‚¤ãƒ‰ã‚’è¡¨ç¤ºã—ãªã„
                });

                if (!retryToken) {
                    throw new BlobOperationError(
                        "BLOB_READ_WRITE_TOKEN ã®å…¥åŠ›ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚",
                        BlobErrorCode.INVALID_TOKEN
                    );
                }

                tokenForCreation = retryToken.trim();
                continue;
            }

            console.error(`âŒ ã‚¹ãƒˆã‚¢ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${error instanceof Error ? error.message : error}`);
            throw error;
        }
    }
}

/**
 * æ—¢å­˜ã‚¹ãƒˆã‚¢é¸æŠãƒ•ãƒ­ãƒ¼
 * @param token ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³
 * @returns é¸æŠã•ã‚ŒãŸã‚¹ãƒˆã‚¢æƒ…å ±
 */
async function selectExistingStore(token: string): Promise<{ storeId: string; storeName: string; storeUrl: string }> {
    console.log("Blobã‚¹ãƒˆã‚¢ä¸€è¦§ã‚’å–å¾—ä¸­...");

    try {
        const stores = await listBlobStores({ token });

        if (stores.length === 0) {
            throw new Error("åˆ©ç”¨å¯èƒ½ãªBlobã‚¹ãƒˆã‚¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ–°è¦ä½œæˆã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
        }

        const selectedStoreId = (await select({
            message: "åˆ©ç”¨ã™ã‚‹Blobã‚¹ãƒˆã‚¢ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼š",
            options: stores.map((store) => ({
                value: store.id,
                label: store.name,
                hint: `ä½œæˆæ—¥: ${new Date(store.createdAt).toLocaleDateString()}`,
            })),
        })) as string;

        const selectedStore = stores.find((store) => store.id === selectedStoreId);
        if (!selectedStore) {
            throw new Error("é¸æŠã•ã‚ŒãŸã‚¹ãƒˆã‚¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
        }

        console.log(`âœ… Blobã‚¹ãƒˆã‚¢ '${selectedStore.name}' ã‚’é¸æŠã—ã¾ã—ãŸ`);

        return {
            storeId: selectedStore.id,
            storeName: selectedStore.name,
            storeUrl: selectedStore.url,
        };
    } catch (error) {
        console.error(`âŒ ã‚¹ãƒˆã‚¢é¸æŠã«å¤±æ•—ã—ã¾ã—ãŸ: ${error instanceof Error ? error.message : error}`);
        throw error;
    }
}

// EOF

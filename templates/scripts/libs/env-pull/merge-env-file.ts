import { access, constants, readFile } from "node:fs/promises";

type EnvLine =
  | { type: "comment"; content: string }
  | { type: "empty"; content: string }
  | { type: "variable"; key: string; value: string; rawLine: string };

const VARIABLE_PATTERN = /^([A-Z_][A-Z0-9_]*)=(.*)$/;

/**
 * 既存の .env ファイルを解析して、行の種類を判別する
 */
function parseEnvFile(content: string): EnvLine[] {
  const lines = content.split("\n");
  const parsed: EnvLine[] = [];

  for (const line of lines) {
    const trimmed = line.trim();

    // 空行
    if (trimmed === "") {
      parsed.push({ type: "empty", content: line });
      continue;
    }

    // コメント行
    if (trimmed.startsWith("#")) {
      parsed.push({ type: "comment", content: line });
      continue;
    }

    // 変数行
    const match = VARIABLE_PATTERN.exec(trimmed);
    if (match) {
      const [, key, value] = match;
      if (key && value !== undefined) {
        parsed.push({ type: "variable", key, value, rawLine: line });
        continue;
      }
    }

    // その他（コメントとして扱う）
    parsed.push({ type: "comment", content: line });
  }

  return parsed;
}

const SAFE_VALUE_PATTERN = /^[A-Za-z0-9_./:-]*$/;

/**
 * 値のエスケープとクォート処理
 */
function formatValue(value: string): string {
  if (value === "") {
    return "";
  }

  if (SAFE_VALUE_PATTERN.test(value)) {
    return value;
  }

  const escaped = value
    .replace(/\\/g, "\\\\")
    .replace(/\n/g, "\\n")
    .replace(/\r/g, "\\r")
    .replace(/\t/g, "\\t")
    .replace(/"/g, '\\"');

  return `"${escaped}"`;
}

/**
 * 既存ファイルを読み込んで解析する
 */
async function loadExistingFile(
  filePath: string
): Promise<{ lines: EnvLine[]; keys: Set<string> }> {
  try {
    await access(filePath, constants.F_OK);
    const content = await readFile(filePath, "utf8");
    const lines = parseEnvFile(content);
    const keys = new Set<string>();

    for (const line of lines) {
      if (line.type === "variable") {
        keys.add(line.key);
      }
    }

    return { lines, keys };
  } catch {
    return { lines: [], keys: new Set() };
  }
}

/**
 * 既存ファイルを更新する
 */
function buildUpdatedLines(
  existingLines: EnvLine[],
  updatedKeys: Set<string>,
  newVariables: Map<string, string>
): string[] {
  const updatedLines: string[] = [];

  for (const line of existingLines) {
    if (line.type === "variable" && updatedKeys.has(line.key)) {
      const newValue = newVariables.get(line.key);
      if (newValue !== undefined) {
        const formattedValue = formatValue(newValue);
        updatedLines.push(`${line.key}=${formattedValue}`);
      } else {
        /* c8 ignore next 2 */
        updatedLines.push(line.rawLine);
      }
    } else if (line.type === "comment") {
      updatedLines.push(line.content);
    } else if (line.type === "empty") {
      updatedLines.push(line.content);
    } else {
      /* c8 ignore next 2 */
      updatedLines.push(line.rawLine);
    }
  }

  return updatedLines;
}

/**
 * 新規変数セクションを構築する
 */
function buildNewVariableSection(
  addedKeys: Set<string>,
  newVariables: Map<string, string>,
  metadata: { appName: string; targetName: string },
  hasExistingContent: boolean
): string[] {
  if (addedKeys.size === 0) {
    return [];
  }

  const section: string[] = [];

  if (hasExistingContent) {
    section.push("");
  }

  section.push("# ========================================");
  section.push("# Added by pnpm env:pull");
  section.push(`# App: ${metadata.appName}`);
  section.push(`# Target: ${metadata.targetName}`);
  section.push("# ========================================");
  section.push("");

  const sortedAddedKeys = [...addedKeys].sort();
  for (const key of sortedAddedKeys) {
    const value = newVariables.get(key);
    if (value !== undefined) {
      const formattedValue = formatValue(value);
      section.push(`${key}=${formattedValue}`);
    }
  }

  return section;
}

/**
 * ファイルが存在しない場合の新規ファイル内容を構築する
 */
function buildFileFromScratch(
  newVariables: Map<string, string>,
  metadata: { appName: string; targetName: string }
): string {
  const header = [
    "# Generated by pnpm env:pull",
    `# App: ${metadata.appName}`,
    `# Target: ${metadata.targetName}`,
    "",
  ];

  const sortedKeys = [...newVariables.keys()].sort();
  const variables = sortedKeys.map((key) => {
    const value = newVariables.get(key);
    if (value !== undefined) {
      const formattedValue = formatValue(value);
      return `${key}=${formattedValue}`;
    }
    /* c8 ignore next */
    return "";
  });

  return `${[...header, ...variables].join("\n")}\n`;
}

/**
 * 既存の環境変数ファイルと新しい変数をマージする
 * - 既存の変数は値のみを更新
 * - 新しい変数は下部に追加（コメント付きセクション）
 */
export async function mergeEnvFile(
  filePath: string,
  newVariables: Map<string, string>,
  metadata: { appName: string; targetName: string }
): Promise<string> {
  const { lines: existingLines, keys: existingKeys } = await loadExistingFile(filePath);

  if (existingLines.length === 0) {
    return buildFileFromScratch(newVariables, metadata);
  }

  const newKeys = new Set(newVariables.keys());
  const updatedKeys = new Set([...newKeys].filter((key) => existingKeys.has(key)));
  const addedKeys = new Set([...newKeys].filter((key) => !existingKeys.has(key)));

  const updatedLines = buildUpdatedLines(existingLines, updatedKeys, newVariables);
  const newSection = buildNewVariableSection(addedKeys, newVariables, metadata, true);

  return `${[...updatedLines, ...newSection].join("\n")}\n`;
}

// EOF

# ãƒ‡ãƒ—ãƒ­ã‚¤ç’°å¢ƒã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—è‡ªå‹•åŒ–

[ STATUS:DONE ]

## ç›®çš„

- Fluorite Flake ç”Ÿæˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§åˆ©ç”¨ä¸­ã® Vercel ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ / Turso Cloud ã¾ãŸã¯ Supabase ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ / Vercel Blob ã‚¹ãƒˆã‚¢ã‚’ã€1 å›ã® CLI æ“ä½œã§å®‰å…¨ã«å‰Šé™¤ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚
- ä¸è¦ã«ãªã£ãŸç’°å¢ƒãƒªã‚½ãƒ¼ã‚¹ã®æ•´ç†ã‚’ç°¡å˜ã«ã—ã€è²»ç”¨ã‚„ãƒªã‚½ãƒ¼ã‚¹æ¶ˆè²»ã‚’æŠ‘ãˆã‚‹ã€‚

## ã‚´ãƒ¼ãƒ«

1. `pnpm cleanup:deploy`ï¼ˆä»®ç§°ï¼‰ã®ã‚ˆã†ãªã‚³ãƒãƒ³ãƒ‰ã‚’ç”¨æ„ã—ã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«å¾“ã†ã ã‘ã§å…¨ãƒªã‚½ãƒ¼ã‚¹å‰Šé™¤ or éƒ¨åˆ†å‰Šé™¤ãŒé¸ã¹ã‚‹ã€‚
2. å‰Šé™¤å‰ã«ç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚„ç¢ºèªæ–‡å­—åˆ—ï¼ˆä¾‹: `delete <project-slug> project`ï¼‰ã‚’å…¥åŠ›ã•ã›ã€èª¤æ“ä½œã‚’é˜²æ­¢ã™ã‚‹ã€‚
3. å‰Šé™¤å¯¾è±¡ã¯ä»¥ä¸‹ã‚’æƒ³å®šï¼š
   - Vercel ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆï¼ˆæœ¬ç•ªï¼ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç’°å¢ƒå«ã‚€ï¼‰
   - Turso DB ã‚»ãƒƒãƒˆï¼ˆdev/stg/prodï¼‰ã¾ãŸã¯ Supabase ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆï¼ˆdev/stg/prodï¼‰
   - Vercel Blob ã‚¹ãƒˆã‚¢
4. å®Ÿè¡Œçµæœã‚’ãƒ­ã‚°å‡ºåŠ›ã—ã€ä½•ãŒå‰Šé™¤ã•ã‚ŒãŸã‹ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç¢ºèªã§ãã‚‹ã€‚

## ã‚¹ã‚³ãƒ¼ãƒ—

- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆTypeScript or Node ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼‰ã‚’è¿½åŠ ã€‚
- `src/utils/vercel-cli`, `src/utils/turso-cli`, `src/utils/supabase-cli` ã«å‰Šé™¤é–¢é€£ã® API ã‚’è¿½åŠ ï¼ˆãƒªã‚½ãƒ¼ã‚¹ ID å–å¾—ã€å‰Šé™¤ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼‰ã€‚
- `package.json` ã« cleanup ç”¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’è¿½åŠ ã—ã€README ã¸æ‰‹é †ã‚’è¨˜è¼‰ã€‚

## ã‚¢ã‚¦ãƒˆã‚ªãƒ–ã‚¹ã‚³ãƒ¼ãƒ—

- å€‹åˆ¥ãƒªã‚½ãƒ¼ã‚¹ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã«äº‹å‰ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä¿ƒã™ï¼‰ã€‚
- Vercel ä»¥å¤–ã®ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°ãƒ»DBãƒ»ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã¸ã®å¯¾å¿œã€‚

## æŠ€è¡“è©³ç´°è¨­è¨ˆ

### 1. ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

```typescript
// ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚·ã‚¹ãƒ†ãƒ æ§‹é€ 
interface CleanupArchitecture {
  // ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†å±¤
  resourceManagement: {
    discovery: 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®šã‹ã‚‰ãƒªã‚½ãƒ¼ã‚¹è‡ªå‹•æ¤œå‡º';
    inventory: 'ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªä½œæˆã¨ä¾å­˜é–¢ä¿‚åˆ†æ';
    classification: 'ãƒªã‚¹ã‚¯åˆ†é¡ã¨å‰Šé™¤é †åºæ±ºå®š';
  };

  // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å±¤
  security: {
    authentication: 'ãƒãƒ«ãƒã‚µãƒ¼ãƒ“ã‚¹èªè¨¼çŠ¶æ…‹ç¢ºèª';
    authorization: 'å‰Šé™¤æ¨©é™æ¤œè¨¼ã¨ã‚¹ã‚³ãƒ¼ãƒ—ãƒã‚§ãƒƒã‚¯';
    auditLog: 'æ“ä½œå±¥æ­´ã®å®Œå…¨è¨˜éŒ²';
  };

  // å®Ÿè¡Œå±¤
  execution: {
    orchestration: 'ä¾å­˜é–¢ä¿‚ã‚’è€ƒæ…®ã—ãŸé †æ¬¡å‰Šé™¤';
    rollback: 'éƒ¨åˆ†å¤±æ•—æ™‚ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½';
    monitoring: 'ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€²æ—è¿½è·¡';
  };
}
```

### 2. ãƒªã‚½ãƒ¼ã‚¹ç™ºè¦‹ãƒ»ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

**å‹•çš„ãƒªã‚½ãƒ¼ã‚¹æ¤œå‡ºã‚¨ãƒ³ã‚¸ãƒ³**ï¼š
```typescript
// src/utils/resource-manager/discovery.ts
export class ResourceDiscovery {
  // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®šã‹ã‚‰ãƒªã‚½ãƒ¼ã‚¹ã‚’è‡ªå‹•æ¤œå‡º
  async discoverProjectResources(projectPath: string): Promise<ProjectInventory> {
    const inventory: ProjectInventory = {
      vercel: await this.discoverVercelResources(projectPath),
      databases: await this.discoverDatabaseResources(projectPath),
      storage: await this.discoverStorageResources(projectPath),
      dependencies: await this.analyzeDependencies(projectPath)
    };

    return this.validateInventory(inventory);
  }

  // Vercelãƒªã‚½ãƒ¼ã‚¹æ¤œå‡º
  private async discoverVercelResources(projectPath: string): Promise<VercelResources> {
    const vercelConfig = await this.readVercelConfig(projectPath);
    const envVars = await this.readEnvironmentVariables(projectPath);

    return {
      projectId: vercelConfig?.projectId || this.extractFromEnv(envVars, 'VERCEL_PROJECT_ID'),
      orgId: vercelConfig?.orgId || this.extractFromEnv(envVars, 'VERCEL_ORG_ID'),
      domains: await this.discoverLinkedDomains(projectPath),
      environmentVariables: this.extractVercelEnvVars(envVars)
    };
  }

  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒªã‚½ãƒ¼ã‚¹æ¤œå‡º
  private async discoverDatabaseResources(projectPath: string): Promise<DatabaseResources> {
    const envVars = await this.readEnvironmentVariables(projectPath);
    const dbType = this.detectDatabaseType(envVars);

    switch (dbType) {
      case 'turso':
        return await this.discoverTursoResources(envVars);
      case 'supabase':
        return await this.discoverSupabaseResources(envVars);
      default:
        return { type: 'none', resources: [] };
    }
  }

  // ä¾å­˜é–¢ä¿‚åˆ†æ
  private async analyzeDependencies(projectPath: string): Promise<DependencyGraph> {
    const resources = await this.discoverProjectResources(projectPath);

    return {
      deletionOrder: this.calculateDeletionOrder(resources),
      riskAssessment: this.assessDeletionRisks(resources),
      backupRequirements: this.identifyBackupRequirements(resources)
    };
  }
}
```

### 3. é«˜åº¦ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚·ã‚¹ãƒ†ãƒ 

**ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–å‰Šé™¤ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼**ï¼š
```typescript
// src/utils/cleanup/prompts.ts
export class CleanupPrompts {
  // ãƒ¡ã‚¤ãƒ³ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ãƒ•ãƒ­ãƒ¼
  async executeCleanupFlow(inventory: ProjectInventory): Promise<CleanupPlan> {
    // 1. ãƒªã‚½ãƒ¼ã‚¹è¡¨ç¤ºã¨é¸æŠ
    const selectedResources = await this.presentResourceSelection(inventory);

    // 2. ãƒªã‚¹ã‚¯è©•ä¾¡è¡¨ç¤º
    await this.displayRiskAssessment(selectedResources);

    // 3. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç¢ºèª
    const backupConfirmed = await this.confirmBackupStatus(selectedResources);
    if (!backupConfirmed) {
      throw new CleanupError('Backup confirmation required');
    }

    // 4. æ®µéšçš„ç¢ºèª
    const plan = await this.createDeletionPlan(selectedResources);
    const userConfirmed = await this.confirmDeletionPlan(plan);

    // 5. æœ€çµ‚ç¢ºèªï¼ˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåå…¥åŠ›ï¼‰
    await this.finalConfirmation(inventory.projectName);

    return plan;
  }

  // ãƒªã‚½ãƒ¼ã‚¹é¸æŠUI
  private async presentResourceSelection(inventory: ProjectInventory): Promise<SelectedResources> {
    const choices = this.buildResourceChoices(inventory);

    const selections = await inquirer.prompt([
      {
        type: 'checkbox',
        name: 'resources',
        message: 'å‰Šé™¤ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼š',
        choices: choices,
        validate: (input) => input.length > 0 || 'å°‘ãªãã¨ã‚‚1ã¤ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„'
      },
      {
        type: 'list',
        name: 'scope',
        message: 'å‰Šé™¤ç¯„å›²ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼š',
        choices: [
          { name: 'é–‹ç™ºç’°å¢ƒã®ã¿', value: 'development' },
          { name: 'ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ç’°å¢ƒã®ã¿', value: 'staging' },
          { name: 'æœ¬ç•ªç’°å¢ƒã®ã¿', value: 'production' },
          { name: 'å…¨ç’°å¢ƒ', value: 'all' }
        ],
        when: (answers) => this.hasMultipleEnvironments(answers.resources)
      }
    ]);

    return this.processSelections(selections, inventory);
  }

  // æœ€çµ‚ç¢ºèª
  private async finalConfirmation(projectName: string): Promise<void> {
    console.log(chalk.red('\nâš ï¸  æœ€çµ‚ç¢ºèª'));
    console.log(chalk.yellow('ã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã™ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚'));
    console.log(chalk.white(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå "${projectName}" ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š\n`));

    const { confirmation } = await inquirer.prompt([
      {
        type: 'input',
        name: 'confirmation',
        message: 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåã‚’å…¥åŠ›ï¼š',
        validate: (input) => {
          if (input.trim() !== projectName) {
            return `"${projectName}" ã¨æ­£ç¢ºã«å…¥åŠ›ã—ã¦ãã ã•ã„`;
          }
          return true;
        }
      }
    ]);

    console.log(chalk.green('âœ“ ç¢ºèªå®Œäº†ã€‚å‰Šé™¤ã‚’é–‹å§‹ã—ã¾ã™...\n'));
  }
}
```

### 4. å‰Šé™¤ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

**ä¾å­˜é–¢ä¿‚å¯¾å¿œå‰Šé™¤ã‚¨ãƒ³ã‚¸ãƒ³**ï¼š
```typescript
// src/utils/cleanup/orchestrator.ts
export class DeletionOrchestrator {
  // ãƒ¡ã‚¤ãƒ³å‰Šé™¤å®Ÿè¡Œ
  async executeDeletionPlan(plan: CleanupPlan): Promise<DeletionResult> {
    const results: DeletionStepResult[] = [];
    let rollbackRequired = false;

    try {
      // å‰Šé™¤ã‚¹ãƒ†ãƒƒãƒ—ã‚’ä¾å­˜é–¢ä¿‚é †ã«å®Ÿè¡Œ
      for (const step of plan.steps) {
        console.log(`ğŸ”§ ${step.description}ã‚’å‰Šé™¤ä¸­...`);

        const stepResult = await this.executeStep(step);
        results.push(stepResult);

        if (!stepResult.success) {
          rollbackRequired = true;
          break;
        }

        // é€²æ—è¡¨ç¤º
        this.displayProgress(results.length, plan.steps.length);
      }

      if (rollbackRequired) {
        await this.executeRollback(results);
      }

      return this.aggregateResults(results, rollbackRequired);

    } catch (error) {
      await this.executeEmergencyRollback(results);
      throw new CleanupError(`Deletion failed: ${error.message}`, error);
    }
  }

  // å€‹åˆ¥ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œ
  private async executeStep(step: DeletionStep): Promise<DeletionStepResult> {
    const startTime = Date.now();

    try {
      switch (step.type) {
        case 'vercel-project':
          return await this.deleteVercelProject(step);
        case 'turso-database':
          return await this.deleteTursoDatabase(step);
        case 'supabase-project':
          return await this.deleteSupabaseProject(step);
        case 'blob-store':
          return await this.deleteBlobStore(step);
        default:
          throw new Error(`Unknown step type: ${step.type}`);
      }
    } catch (error) {
      return {
        step,
        success: false,
        error: error.message,
        duration: Date.now() - startTime,
        rollbackData: step.rollbackData
      };
    }
  }

  // Vercelãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå‰Šé™¤
  private async deleteVercelProject(step: DeletionStep): Promise<DeletionStepResult> {
    const { projectId } = step.parameters;

    // å‰Šé™¤å‰ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆå–å¾—
    const snapshot = await this.captureVercelSnapshot(projectId);

    // å®Ÿéš›ã®å‰Šé™¤å®Ÿè¡Œ
    const result = await VercelCLI.projectRemove(projectId, {
      yes: true // ç¢ºèªã‚¹ã‚­ãƒƒãƒ—ï¼ˆäº‹å‰ç¢ºèªæ¸ˆã¿ï¼‰
    });

    if (!result.success) {
      throw new Error(`Vercel project deletion failed: ${result.stderr}`);
    }

    return {
      step,
      success: true,
      duration: Date.now() - step.startTime,
      rollbackData: { snapshot, projectId }
    };
  }

  // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ
  private async executeRollback(results: DeletionStepResult[]): Promise<void> {
    console.log(chalk.yellow('\nğŸ”„ ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å®Ÿè¡Œä¸­...'));

    // æˆåŠŸã—ãŸã‚¹ãƒ†ãƒƒãƒ—ã‚’é€†é †ã§ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
    const successfulSteps = results.filter(r => r.success).reverse();

    for (const result of successfulSteps) {
      try {
        await this.rollbackStep(result);
        console.log(`âœ“ ${result.step.description}ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Œäº†`);
      } catch (error) {
        console.error(`âœ— ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å¤±æ•—: ${result.step.description}: ${error.message}`);
      }
    }
  }
}
```

### 5. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»å¾©æ—§ã‚·ã‚¹ãƒ†ãƒ 

**äº‹å‰ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç®¡ç†**ï¼š
```typescript
// src/utils/cleanup/backup-manager.ts
export class BackupManager {
  // å‰Šé™¤å‰ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
  async createPreDeletionBackup(plan: CleanupPlan): Promise<BackupManifest> {
    const backups: BackupEntry[] = [];

    for (const step of plan.steps) {
      if (step.requiresBackup) {
        const backup = await this.createStepBackup(step);
        backups.push(backup);
      }
    }

    const manifest: BackupManifest = {
      timestamp: new Date().toISOString(),
      projectName: plan.projectName,
      backups,
      metadata: {
        toolVersion: this.getToolVersion(),
        environment: process.env.NODE_ENV || 'development'
      }
    };

    await this.saveBackupManifest(manifest);
    return manifest;
  }

  // ã‚¹ãƒ†ãƒƒãƒ—åˆ¥ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
  private async createStepBackup(step: DeletionStep): Promise<BackupEntry> {
    switch (step.type) {
      case 'vercel-project':
        return await this.backupVercelProject(step);
      case 'turso-database':
        return await this.backupTursoDatabase(step);
      case 'supabase-project':
        return await this.backupSupabaseProject(step);
      default:
        return { type: step.type, status: 'skipped', reason: 'Backup not supported' };
    }
  }

  // Vercelãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
  private async backupVercelProject(step: DeletionStep): Promise<BackupEntry> {
    const { projectId } = step.parameters;

    // ç’°å¢ƒå¤‰æ•°ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
    const envVars = await VercelCLI.envList();

    // ãƒ‰ãƒ¡ã‚¤ãƒ³è¨­å®šã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
    const domains = await VercelCLI.domainsList();

    // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®šã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
    const projectSettings = await this.exportProjectSettings(projectId);

    const backupData = {
      environmentVariables: envVars.stdout,
      domains: domains.stdout,
      projectSettings,
      timestamp: new Date().toISOString()
    };

    const backupPath = await this.saveBackupData(
      `vercel-${projectId}`,
      backupData
    );

    return {
      type: 'vercel-project',
      status: 'completed',
      path: backupPath,
      size: await this.getFileSize(backupPath),
      metadata: { projectId }
    };
  }
}
```

### 6. ç›£æŸ»ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ 

**åŒ…æ‹¬çš„æ“ä½œãƒ­ã‚°**ï¼š
```typescript
// src/utils/cleanup/audit-logger.ts
export class AuditLogger {
  // æ“ä½œãƒ­ã‚°è¨˜éŒ²
  async logCleanupOperation(operation: CleanupOperation): Promise<void> {
    const logEntry: AuditLogEntry = {
      timestamp: new Date().toISOString(),
      operation: {
        type: 'cleanup',
        projectName: operation.projectName,
        initiatedBy: await this.getCurrentUser(),
        sessionId: this.generateSessionId()
      },
      resources: operation.plan.steps.map(step => ({
        type: step.type,
        identifier: step.parameters.id || step.parameters.name,
        environment: step.environment,
        status: 'planned'
      })),
      metadata: {
        toolVersion: this.getToolVersion(),
        platform: process.platform,
        nodeVersion: process.version
      }
    };

    await this.writeLogEntry(logEntry);
  }

  // å®Ÿè¡Œçµæœãƒ­ã‚°æ›´æ–°
  async updateExecutionResults(
    sessionId: string,
    results: DeletionResult
  ): Promise<void> {
    const updateEntry: LogUpdateEntry = {
      timestamp: new Date().toISOString(),
      sessionId,
      results: {
        overallSuccess: results.success,
        completedSteps: results.completed,
        failedSteps: results.failed,
        rollbackPerformed: results.rollbackPerformed,
        duration: results.totalDuration
      },
      stepDetails: results.stepResults.map(step => ({
        type: step.step.type,
        identifier: step.step.parameters.id,
        success: step.success,
        duration: step.duration,
        error: step.error
      }))
    };

    await this.appendLogUpdate(updateEntry);
  }

  // ãƒ­ã‚°ã®æš—å·åŒ–ä¿å­˜
  private async writeLogEntry(entry: AuditLogEntry): Promise<void> {
    const logFile = this.getLogFilePath(entry.timestamp);
    const encryptedData = await this.encryptLogData(entry);

    await fs.writeFile(logFile, encryptedData, { mode: 0o600 });
  }
}
```

## è§£æ±ºæ¸ˆã¿äº‹é …

- âœ… **ç’°å¢ƒå¤‰æ•°ã‚­ãƒ¼ã®çµ±ä¸€**ï¼š
  - **æ—¢å­˜èª¿æŸ»**: plan 0011/0012ã§ç¢ºç«‹ã•ã‚ŒãŸå‘½åè¦å‰‡ã«æº–æ‹ 
  - **Vercel**: `VERCEL_ORG_ID`, `VERCEL_PROJECT_ID` (vercel.jsonã‹ã‚‰å–å¾—)
  - **Turso**: `TURSO_DATABASE_URL_*`, `TURSO_AUTH_TOKEN_*` (Suffixæ–¹å¼)
  - **Supabase**: `NEXT_PUBLIC_SUPABASE_URL_*`, ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆRef (è¤‡æ•°ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ–¹å¼)
  - **Blob**: `BLOB_STORE_ID_*`, `BLOB_READ_WRITE_TOKEN_*`

- âœ… **Supabaseåˆ†é›¢æ–¹æ³•**ï¼š
  - **åˆ†é›¢æ–¹å¼**: ç’°å¢ƒã”ã¨ã«ç‹¬ç«‹ã—ãŸSupabaseãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ
  - **æ§‹é€ **: `project-dev`, `project-stg`, `project-prod`
  - **è­˜åˆ¥å­**: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆRefï¼ˆ24æ–‡å­—ã®è‹±æ•°å­—ï¼‰
  - **å‰Šé™¤æ–¹å¼**: å„ç’°å¢ƒã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’å€‹åˆ¥å‰Šé™¤

- âœ… **å‰Šé™¤ã‚³ãƒãƒ³ãƒ‰APIæ¤œè¨¼**ï¼š
  - **Vercel**: `vercel project rm <name>` å®‰å®šå‹•ä½œç¢ºèªæ¸ˆã¿
  - **Turso**: `turso db destroy <name> --yes` ãƒãƒƒãƒå‰Šé™¤å¯¾å¿œ
  - **Supabase**: `supabase projects delete <ref>` ç¢ºèªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå†…è”µ
  - **å…±é€š**: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨å†ªç­‰æ€§ä¿è¨¼æ¸ˆã¿

- âœ… **ãƒ­ã‚°å‡ºåŠ›å½¢å¼çµ±ä¸€**ï¼š
  - **æ§‹é€ åŒ–ãƒ­ã‚°**: JSONå½¢å¼ã§æ“ä½œå±¥æ­´ã¨ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¨˜éŒ²
  - **ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡¨ç¤º**: è‰²åˆ†ã‘ã•ã‚ŒãŸé€²æ—ã¨ã‚µãƒãƒªãƒ¼è¡¨ç¤º
  - **ç›£æŸ»ãƒ­ã‚°**: `cleanup-log-YYYYMMDD-HHMMSS.json`å½¢å¼ã§æ°¸ç¶šåŒ–
  - **ã‚¨ãƒ©ãƒ¼ãƒˆãƒ¬ãƒ¼ã‚¹**: è©³ç´°ãªã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã¨å¾©æ—§ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æˆ¦ç•¥

### 1. å¤šå±¤é˜²å¾¡ã‚·ã‚¹ãƒ†ãƒ 

**èªè¨¼ãƒ»èªå¯ãƒã‚§ãƒ¼ãƒ³**ï¼š
```typescript
// src/utils/cleanup/security.ts
export class SecurityManager {
  // ãƒãƒ«ãƒã‚µãƒ¼ãƒ“ã‚¹èªè¨¼ç¢ºèª
  async validateAuthentication(): Promise<AuthenticationStatus> {
    const authResults = await Promise.allSettled([
      this.checkVercelAuth(),
      this.checkTursoAuth(),
      this.checkSupabaseAuth()
    ]);

    return {
      vercel: this.processAuthResult(authResults[0]),
      turso: this.processAuthResult(authResults[1]),
      supabase: this.processAuthResult(authResults[2]),
      overallValid: authResults.every(result => result.status === 'fulfilled')
    };
  }

  // å‰Šé™¤æ¨©é™æ¤œè¨¼
  async validatePermissions(plan: CleanupPlan): Promise<PermissionStatus> {
    const permissions: PermissionCheck[] = [];

    for (const step of plan.steps) {
      const permission = await this.checkStepPermissions(step);
      permissions.push(permission);
    }

    return {
      checks: permissions,
      allValid: permissions.every(p => p.authorized),
      restrictions: permissions.filter(p => !p.authorized)
    };
  }

  // æ“ä½œç¯„å›²åˆ¶é™
  async validateOperationScope(
    resources: SelectedResources,
    userContext: UserContext
  ): Promise<ScopeValidation> {
    const violations: ScopeViolation[] = [];

    // æœ¬ç•ªç’°å¢ƒå‰Šé™¤åˆ¶é™ãƒã‚§ãƒƒã‚¯
    if (resources.environments.includes('production')) {
      const prodAuthz = await this.checkProductionAuthorization(userContext);
      if (!prodAuthz.authorized) {
        violations.push({
          type: 'production_restriction',
          message: 'æœ¬ç•ªç’°å¢ƒå‰Šé™¤ã«ã¯ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™',
          severity: 'critical'
        });
      }
    }

    // å…±æœ‰ãƒªã‚½ãƒ¼ã‚¹å‰Šé™¤åˆ¶é™ãƒã‚§ãƒƒã‚¯
    const sharedResources = await this.identifySharedResources(resources);
    if (sharedResources.length > 0) {
      violations.push({
        type: 'shared_resource',
        message: 'å…±æœ‰ãƒªã‚½ãƒ¼ã‚¹ã®å‰Šé™¤ã¯åˆ¶é™ã•ã‚Œã¦ã„ã¾ã™',
        severity: 'high',
        affectedResources: sharedResources
      });
    }

    return {
      valid: violations.length === 0,
      violations,
      recommendations: this.generateSecurityRecommendations(violations)
    };
  }
}
```

### 2. æ“ä½œç›£æŸ»ã‚·ã‚¹ãƒ†ãƒ 

**åŒ…æ‹¬çš„ç›£æŸ»ãƒ­ã‚°**ï¼š
```typescript
// src/utils/cleanup/audit.ts
export class AuditSystem {
  // æ“ä½œå‰ç›£æŸ»
  async auditPreOperation(plan: CleanupPlan): Promise<AuditReport> {
    const auditData = {
      timestamp: new Date().toISOString(),
      operation: 'cleanup_initiation',
      user: await this.getCurrentUserInfo(),
      resources: plan.steps.map(this.mapStepToAuditEntry),
      riskAssessment: await this.assessOperationRisk(plan),
      approvals: await this.checkRequiredApprovals(plan)
    };

    await this.recordAuditEvent(auditData);
    return this.generateAuditReport(auditData);
  }

  // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ“ä½œãƒ­ã‚°
  async logOperationStep(
    step: DeletionStep,
    result: DeletionStepResult
  ): Promise<void> {
    const logEntry = {
      timestamp: new Date().toISOString(),
      step: {
        type: step.type,
        identifier: step.parameters.id,
        environment: step.environment
      },
      result: {
        success: result.success,
        duration: result.duration,
        error: result.error,
        rollbackRequired: !!result.rollbackData
      },
      metadata: {
        sessionId: this.getSessionId(),
        userAgent: this.getUserAgent(),
        ipAddress: await this.getClientIP()
      }
    };

    await this.appendToOperationLog(logEntry);
  }

  // æ“ä½œå¾Œç›£æŸ»
  async auditPostOperation(
    plan: CleanupPlan,
    results: DeletionResult
  ): Promise<void> {
    const postAuditData = {
      timestamp: new Date().toISOString(),
      operation: 'cleanup_completion',
      originalPlan: plan,
      actualResults: results,
      compliance: await this.checkComplianceRequirements(results),
      impact: await this.assessOperationImpact(results)
    };

    await this.recordAuditEvent(postAuditData);
    await this.notifyStakeholders(postAuditData);
  }
}
```

### 3. ãƒ‡ãƒ¼ã‚¿ä¿è­·æ©Ÿèƒ½

**æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ä¿è­·**ï¼š
```typescript
// src/utils/cleanup/data-protection.ts
export class DataProtectionManager {
  // æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿æ¤œå‡º
  async scanForSensitiveData(resources: SelectedResources): Promise<SensitiveDataReport> {
    const findings: SensitiveDataFinding[] = [];

    for (const resource of resources.all) {
      const scan = await this.scanResource(resource);
      if (scan.containsSensitiveData) {
        findings.push(scan);
      }
    }

    return {
      findings,
      riskLevel: this.calculateDataRisk(findings),
      recommendations: this.generateDataProtectionRecommendations(findings)
    };
  }

  // ãƒ‡ãƒ¼ã‚¿ãƒã‚¹ã‚­ãƒ³ã‚°
  async maskSensitiveData(data: any): Promise<MaskedData> {
    const patterns = [
      /(?:password|secret|key|token)[\s\\":=]+[^\s\n,}]+/gi,
      /[\w\.-]+@[\w\.-]+\.\w+/gi, // Email addresses
      /\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/g // Credit card patterns
    ];

    let maskedData = JSON.stringify(data);
    patterns.forEach(pattern => {
      maskedData = maskedData.replace(pattern, '[MASKED]');
    });

    return {
      data: JSON.parse(maskedData),
      maskingApplied: true,
      originalDataHash: this.hashData(data)
    };
  }

  // ãƒ‡ãƒ¼ã‚¿å®Œå…¨å‰Šé™¤ç¢ºèª
  async verifyDataDeletion(deletedResources: DeletedResource[]): Promise<DeletionVerification> {
    const verificationResults: ResourceDeletionStatus[] = [];

    for (const resource of deletedResources) {
      const status = await this.verifyResourceDeletion(resource);
      verificationResults.push(status);
    }

    return {
      allDeleted: verificationResults.every(r => r.fullyDeleted),
      results: verificationResults,
      recommendations: this.generateDeletionRecommendations(verificationResults)
    };
  }
}
```

## ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æˆ¦ç•¥

### 1. éšå±¤åŒ–ã‚¨ãƒ©ãƒ¼å‡¦ç†

**åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼åˆ†é¡**ï¼š
```typescript
// src/utils/cleanup/error-handling.ts
export class ErrorHandler {
  // ã‚¨ãƒ©ãƒ¼åˆ†é¡ã¨å‡¦ç†
  async handleCleanupError(error: Error, context: ErrorContext): Promise<ErrorResponse> {
    const errorType = this.classifyError(error, context);

    switch (errorType.category) {
      case 'authentication':
        return await this.handleAuthenticationError(error, context);
      case 'authorization':
        return await this.handleAuthorizationError(error, context);
      case 'network':
        return await this.handleNetworkError(error, context);
      case 'resource_not_found':
        return await this.handleResourceNotFoundError(error, context);
      case 'resource_in_use':
        return await this.handleResourceInUseError(error, context);
      case 'quota_exceeded':
        return await this.handleQuotaError(error, context);
      case 'system':
        return await this.handleSystemError(error, context);
      default:
        return await this.handleUnknownError(error, context);
    }
  }

  // èªè¨¼ã‚¨ãƒ©ãƒ¼å‡¦ç†
  private async handleAuthenticationError(
    error: Error,
    context: ErrorContext
  ): Promise<ErrorResponse> {
    const service = this.identifyService(context);

    return {
      type: 'authentication_error',
      message: `${service}ã¸ã®èªè¨¼ãŒå¿…è¦ã§ã™`,
      action: 'require_auth',
      recovery: {
        steps: [
          `${service} CLIã§å†ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„`,
          'ãƒ­ã‚°ã‚¤ãƒ³å¾Œã€æ“ä½œã‚’å†å®Ÿè¡Œã—ã¦ãã ã•ã„'
        ],
        commands: this.getAuthCommands(service),
        automated: false
      },
      retryable: true,
      severity: 'medium'
    };
  }

  // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼å‡¦ç†ï¼ˆãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ä»˜ãï¼‰
  private async handleNetworkError(
    error: Error,
    context: ErrorContext
  ): Promise<ErrorResponse> {
    const retryConfig = this.getRetryConfig(context);

    if (context.retryCount < retryConfig.maxRetries) {
      const delay = this.calculateBackoffDelay(context.retryCount);

      return {
        type: 'network_error',
        message: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ',
        action: 'auto_retry',
        recovery: {
          steps: [`${delay}mså¾Œã«è‡ªå‹•ãƒªãƒˆãƒ©ã‚¤ã—ã¾ã™`],
          automated: true,
          retryAfter: delay
        },
        retryable: true,
        severity: 'low'
      };
    }

    return {
      type: 'network_error_final',
      message: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ï¼šãƒªãƒˆãƒ©ã‚¤å›æ•°ãŒä¸Šé™ã«é”ã—ã¾ã—ãŸ',
      action: 'manual_intervention',
      recovery: {
        steps: [
          'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„',
          'ã—ã°ã‚‰ãæ™‚é–“ã‚’ãŠã„ã¦å†å®Ÿè¡Œã—ã¦ãã ã•ã„'
        ],
        automated: false
      },
      retryable: false,
      severity: 'high'
    };
  }

  // ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨ä¸­ã‚¨ãƒ©ãƒ¼å‡¦ç†
  private async handleResourceInUseError(
    error: Error,
    context: ErrorContext
  ): Promise<ErrorResponse> {
    const dependencies = await this.identifyResourceDependencies(context.resource);

    return {
      type: 'resource_in_use',
      message: 'ãƒªã‚½ãƒ¼ã‚¹ãŒä½¿ç”¨ä¸­ã®ãŸã‚å‰Šé™¤ã§ãã¾ã›ã‚“',
      action: 'resolve_dependencies',
      recovery: {
        steps: [
          'ä»¥ä¸‹ã®ä¾å­˜é–¢ä¿‚ã‚’å…ˆã«å‰Šé™¤ã—ã¦ãã ã•ã„ï¼š',
          ...dependencies.map(dep => `- ${dep.name} (${dep.type})`),
          'ãã®å¾Œã€å…ƒã®å‰Šé™¤æ“ä½œã‚’å†å®Ÿè¡Œã—ã¦ãã ã•ã„'
        ],
        automated: false,
        dependencies
      },
      retryable: true,
      severity: 'medium'
    };
  }
}
```

### 2. é«˜åº¦ãªãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½

**ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯**ï¼š
```typescript
// src/utils/cleanup/rollback.ts
export class AdvancedRollbackManager {
  // ã‚¹ãƒãƒ¼ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ
  async executeIntelligentRollback(
    failedStep: DeletionStepResult,
    completedSteps: DeletionStepResult[]
  ): Promise<RollbackResult> {
    const rollbackPlan = await this.createRollbackPlan(failedStep, completedSteps);

    console.log(chalk.yellow('\nğŸ”„ ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’é–‹å§‹ã—ã¾ã™...'));

    const rollbackResults: RollbackStepResult[] = [];

    for (const step of rollbackPlan.steps) {
      try {
        const result = await this.executeRollbackStep(step);
        rollbackResults.push(result);

        if (result.success) {
          console.log(chalk.green(`âœ“ ${step.description}ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Œäº†`));
        } else {
          console.log(chalk.red(`âœ— ${step.description}ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å¤±æ•—: ${result.error}`));
        }
      } catch (error) {
        console.error(chalk.red(`âš ï¸ ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: ${error.message}`));
      }
    }

    return this.aggregateRollbackResults(rollbackResults);
  }

  // éƒ¨åˆ†ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆ¦ç•¥
  async createRollbackPlan(
    failedStep: DeletionStepResult,
    completedSteps: DeletionStepResult[]
  ): Promise<RollbackPlan> {
    const dependencies = this.analyzeDependencies(completedSteps);
    const rollbackSteps: RollbackStep[] = [];

    // å¤±æ•—ã‚¹ãƒ†ãƒƒãƒ—ã®ä¾å­˜é–¢ä¿‚ã«åŸºã¥ã„ã¦ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ç¯„å›²ã‚’æ±ºå®š
    const affectedSteps = this.identifyAffectedSteps(failedStep, dependencies);

    for (const step of affectedSteps.reverse()) {
      if (this.canRollback(step)) {
        rollbackSteps.push(this.createRollbackStep(step));
      } else {
        // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ä¸å¯èƒ½ãªå ´åˆã¯è­¦å‘Šã‚’è¨˜éŒ²
        console.warn(chalk.yellow(`âš ï¸ ${step.step.description}ã¯ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§ãã¾ã›ã‚“`));
      }
    }

    return {
      steps: rollbackSteps,
      strategy: this.determineRollbackStrategy(affectedSteps),
      estimatedDuration: this.estimateRollbackDuration(rollbackSteps)
    };
  }

  // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§æ¤œè¨¼
  async verifyDataConsistency(
    preState: SystemSnapshot,
    postRollbackState: SystemSnapshot
  ): Promise<ConsistencyReport> {
    const inconsistencies: DataInconsistency[] = [];

    // ãƒªã‚½ãƒ¼ã‚¹çŠ¶æ…‹æ¯”è¼ƒ
    const resourceComparison = this.compareResourceStates(
      preState.resources,
      postRollbackState.resources
    );

    if (!resourceComparison.consistent) {
      inconsistencies.push(...resourceComparison.differences);
    }

    // è¨­å®šçŠ¶æ…‹æ¯”è¼ƒ
    const configComparison = this.compareConfigStates(
      preState.configurations,
      postRollbackState.configurations
    );

    if (!configComparison.consistent) {
      inconsistencies.push(...configComparison.differences);
    }

    return {
      consistent: inconsistencies.length === 0,
      inconsistencies,
      recommendations: this.generateConsistencyRecommendations(inconsistencies)
    };
  }
}
```

### 3. è‡ªå‹•å¾©æ—§ã‚·ã‚¹ãƒ†ãƒ 

**éšœå®³æ¤œå‡ºãƒ»å¾©æ—§**ï¼š
```typescript
// src/utils/cleanup/recovery.ts
export class AutoRecoverySystem {
  // è‡ªå‹•éšœå®³æ¤œå‡º
  async detectAndRecover(operation: CleanupOperation): Promise<RecoveryResult> {
    const healthCheck = await this.performHealthCheck(operation);

    if (!healthCheck.healthy) {
      const recoveryStrategy = this.selectRecoveryStrategy(healthCheck.issues);
      return await this.executeRecoveryStrategy(recoveryStrategy, operation);
    }

    return { recovered: true, issues: [], actions: [] };
  }

  // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ
  private async performHealthCheck(operation: CleanupOperation): Promise<HealthCheckResult> {
    const checks = [
      this.checkServiceConnectivity(),
      this.checkAuthentication(),
      this.checkResourceState(),
      this.checkSystemResources()
    ];

    const results = await Promise.allSettled(checks);
    const issues = results
      .filter(result => result.status === 'rejected')
      .map(result => result.reason);

    return {
      healthy: issues.length === 0,
      issues,
      timestamp: new Date().toISOString()
    };
  }

  // å¾©æ—§æˆ¦ç•¥å®Ÿè¡Œ
  private async executeRecoveryStrategy(
    strategy: RecoveryStrategy,
    operation: CleanupOperation
  ): Promise<RecoveryResult> {
    const actions: RecoveryAction[] = [];

    for (const step of strategy.steps) {
      try {
        const action = await this.executeRecoveryStep(step, operation);
        actions.push(action);

        if (!action.success) {
          break; // å¾©æ—§å¤±æ•—æ™‚ã¯ä¸­æ­¢
        }
      } catch (error) {
        actions.push({
          step: step.type,
          success: false,
          error: error.message,
          timestamp: new Date().toISOString()
        });
        break;
      }
    }

    const recovered = actions.every(action => action.success);

    if (recovered) {
      console.log(chalk.green('âœ“ ã‚·ã‚¹ãƒ†ãƒ å¾©æ—§ãŒå®Œäº†ã—ã¾ã—ãŸ'));
    } else {
      console.log(chalk.red('âœ— è‡ªå‹•å¾©æ—§ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ‰‹å‹•å¯¾å¿œãŒå¿…è¦ã§ã™'));
    }

    return { recovered, issues: strategy.issues, actions };
  }
}

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### 1. åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

**å¤šå±¤ãƒ†ã‚¹ãƒˆæˆ¦ç•¥**ï¼š
```typescript
// test/unit/cleanup/test-strategy.ts
export interface TestStrategy {
  unitTests: {
    coverage: '95%ä»¥ä¸Šã®ã‚³ãƒ¼ãƒ‰ã‚«ãƒãƒ¬ãƒƒã‚¸';
    focus: 'ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã€ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°';
    framework: 'Vitest + TypeScript';
  };

  integrationTests: {
    coverage: 'ä¸»è¦ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å®Œå…¨ãƒ†ã‚¹ãƒˆ';
    focus: 'CLIçµ±åˆã€APIå‘¼ã³å‡ºã—ã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ãƒ­ãƒ¼';
    environment: 'ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹ç’°å¢ƒã§ã®å®Ÿè¡Œ';
  };

  e2eTests: {
    coverage: 'å®Ÿéš›ã®ãƒªã‚½ãƒ¼ã‚¹ä½œæˆãƒ»å‰Šé™¤ã‚µã‚¤ã‚¯ãƒ«';
    focus: 'ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰å‰Šé™¤ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼';
    environment: 'å°‚ç”¨ãƒ†ã‚¹ãƒˆç’°å¢ƒ';
  };
}
```

### 2. å˜ä½“ãƒ†ã‚¹ãƒˆè©³ç´°è¨­è¨ˆ

**ã‚³ã‚¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ†ã‚¹ãƒˆ**ï¼š
```typescript
// test/unit/cleanup/resource-discovery.test.ts
describe('ResourceDiscovery', () => {
  // ãƒªã‚½ãƒ¼ã‚¹æ¤œå‡ºãƒ†ã‚¹ãƒˆ
  describe('ãƒªã‚½ãƒ¼ã‚¹æ¤œå‡ºæ©Ÿèƒ½', () => {
    test('Vercelãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¤œå‡º', async () => {
      // ãƒ¢ãƒƒã‚¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®š
      const mockVercelConfig = {
        projectId: 'test-project-id',
        orgId: 'test-org-id'
      };

      // æœŸå¾…å€¤
      const expectedResources = {
        projectId: 'test-project-id',
        orgId: 'test-org-id',
        domains: [],
        environmentVariables: []
      };

      // å®Ÿè¡Œã¨æ¤œè¨¼
      const discovery = new ResourceDiscovery();
      const result = await discovery.discoverVercelResources('/mock/path');

      expect(result).toEqual(expectedResources);
    });

    test('Tursoãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¤œå‡º', async () => {
      // ç’°å¢ƒå¤‰æ•°ãƒ¢ãƒƒã‚¯
      const mockEnvVars = {
        'TURSO_DATABASE_URL_DEV': 'libsql://dev-db.turso.io',
        'TURSO_AUTH_TOKEN_DEV': 'mock-token-dev'
      };

      // æœŸå¾…å€¤æ¤œè¨¼
      const discovery = new ResourceDiscovery();
      const result = await discovery.discoverTursoResources(mockEnvVars);

      expect(result.type).toBe('turso');
      expect(result.resources).toHaveLength(1);
      expect(result.resources[0].environment).toBe('development');
    });

    test('ä¾å­˜é–¢ä¿‚åˆ†æ', async () => {
      // è¤‡åˆãƒªã‚½ãƒ¼ã‚¹è¨­å®š
      const mockResources = createMockProjectInventory();

      // å‰Šé™¤é †åºæ¤œè¨¼
      const discovery = new ResourceDiscovery();
      const dependencies = await discovery.analyzeDependencies('/mock/path');

      expect(dependencies.deletionOrder).toEqual([
        { type: 'blob-store', priority: 1 },
        { type: 'vercel-project', priority: 2 },
        { type: 'turso-database', priority: 3 }
      ]);
    });
  });

  // ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ
  describe('ã‚¨ãƒ©ãƒ¼å‡¦ç†', () => {
    test('è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä¸æ­£æ™‚ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°', async () => {
      // ä¸æ­£ãªè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãƒ¢ãƒƒã‚¯
      const invalidConfigPath = '/invalid/path';

      const discovery = new ResourceDiscovery();

      await expect(
        discovery.discoverProjectResources(invalidConfigPath)
      ).rejects.toThrow('è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    });
  });
});
```

**ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ**ï¼š
```typescript
// test/unit/cleanup/prompts.test.ts
describe('CleanupPrompts', () => {
  // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ã‚¹ãƒˆ
  describe('ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ãƒ­ãƒ¼', () => {
    test('ãƒªã‚½ãƒ¼ã‚¹é¸æŠãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ', async () => {
      // inquirerãƒ¢ãƒƒã‚¯è¨­å®š
      const mockInquirer = {
        prompt: jest.fn().mockResolvedValue({
          resources: ['vercel', 'turso'],
          scope: 'development'
        })
      };

      // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
      const prompts = new CleanupPrompts(mockInquirer);
      const result = await prompts.presentResourceSelection(mockInventory);

      expect(result.selectedTypes).toContain('vercel');
      expect(result.selectedTypes).toContain('turso');
      expect(result.scope).toBe('development');
    });

    test('æœ€çµ‚ç¢ºèªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ', async () => {
      // æ­£ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåå…¥åŠ›
      const mockInquirer = {
        prompt: jest.fn().mockResolvedValue({
          confirmation: 'test-project'
        })
      };

      const prompts = new CleanupPrompts(mockInquirer);

      // ä¾‹å¤–ãŒç™ºç”Ÿã—ãªã„ã“ã¨ã‚’ç¢ºèª
      await expect(
        prompts.finalConfirmation('test-project')
      ).resolves.not.toThrow();
    });

    test('ä¸æ­£ãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåã§ã®ã‚¨ãƒ©ãƒ¼', async () => {
      // é–“é•ã£ãŸãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåå…¥åŠ›
      const mockInquirer = {
        prompt: jest.fn().mockResolvedValue({
          confirmation: 'wrong-project'
        })
      };

      const prompts = new CleanupPrompts(mockInquirer);

      await expect(
        prompts.finalConfirmation('test-project')
      ).rejects.toThrow('ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåãŒä¸€è‡´ã—ã¾ã›ã‚“');
    });
  });
});
```

### 3. çµ±åˆãƒ†ã‚¹ãƒˆè¨­è¨ˆ

**CLIçµ±åˆãƒ†ã‚¹ãƒˆ**ï¼š
```typescript
// test/integration/cleanup/cli-integration.test.ts
describe('Cleanup CLI Integration', () => {
  // ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹ç’°å¢ƒè¨­å®š
  beforeEach(async () => {
    await setupSandboxEnvironment();
  });

  afterEach(async () => {
    await cleanupSandboxEnvironment();
  });

  describe('å®Œå…¨å‰Šé™¤ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼', () => {
    test('é–‹ç™ºç’°å¢ƒãƒªã‚½ãƒ¼ã‚¹å‰Šé™¤', async () => {
      // ãƒ†ã‚¹ãƒˆç”¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
      const testProject = await createTestProject({
        type: 'nextjs-fullstack-admin',
        database: 'turso',
        environment: 'development'
      });

      // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—CLIå®Ÿè¡Œ
      const cleanupProcess = spawn('pnpm', ['cleanup:deploy'], {
        stdio: 'pipe',
        cwd: testProject.path
      });

      // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå¿œç­”ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
      cleanupProcess.stdin.write('1\n'); // é–‹ç™ºç’°å¢ƒé¸æŠ
      cleanupProcess.stdin.write('1\n'); // Tursoé¸æŠ
      cleanupProcess.stdin.write('y\n'); // ç¢ºèª
      cleanupProcess.stdin.write(`${testProject.name}\n`); // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåç¢ºèª

      // å®Ÿè¡Œçµæœæ¤œè¨¼
      const result = await waitForProcessCompletion(cleanupProcess);

      expect(result.exitCode).toBe(0);
      expect(result.stdout).toContain('âœ… å‰Šé™¤ãŒå®Œäº†ã—ã¾ã—ãŸ');

      // ãƒªã‚½ãƒ¼ã‚¹å‰Šé™¤ç¢ºèª
      const verification = await verifyResourceDeletion(testProject);
      expect(verification.allDeleted).toBe(true);
    });

    test('éƒ¨åˆ†å‰Šé™¤ï¼ˆVercelã®ã¿ï¼‰', async () => {
      // éƒ¨åˆ†å‰Šé™¤ãƒ†ã‚¹ãƒˆå®Ÿè£…
      const testProject = await createTestProject({
        type: 'nextjs-fullstack-admin',
        database: 'supabase',
        environment: 'staging'
      });

      // Vercelã®ã¿å‰Šé™¤å®Ÿè¡Œ
      const cleanupProcess = spawn('pnpm', ['cleanup:deploy'], {
        stdio: 'pipe',
        cwd: testProject.path
      });

      // Vercelå‰Šé™¤ã®ã¿é¸æŠ
      cleanupProcess.stdin.write('2\n'); // ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ç’°å¢ƒ
      cleanupProcess.stdin.write('1\n'); // Vercelã®ã¿
      cleanupProcess.stdin.write('y\n'); // ç¢ºèª
      cleanupProcess.stdin.write(`${testProject.name}\n`);

      const result = await waitForProcessCompletion(cleanupProcess);

      expect(result.exitCode).toBe(0);

      // Vercelå‰Šé™¤ã€Supabaseæ®‹å­˜ç¢ºèª
      const verification = await verifyPartialDeletion(testProject);
      expect(verification.vercelDeleted).toBe(true);
      expect(verification.supabaseExists).toBe(true);
    });
  });

  describe('ã‚¨ãƒ©ãƒ¼ã‚·ãƒŠãƒªã‚ª', () => {
    test('èªè¨¼ã‚¨ãƒ©ãƒ¼æ™‚ã®å‡¦ç†', async () => {
      // èªè¨¼æƒ…å ±ã‚’ç„¡åŠ¹åŒ–
      await invalidateVercelAuth();

      const testProject = await createTestProject();

      const cleanupProcess = spawn('pnpm', ['cleanup:deploy'], {
        stdio: 'pipe',
        cwd: testProject.path
      });

      const result = await waitForProcessCompletion(cleanupProcess);

      // èªè¨¼ã‚¨ãƒ©ãƒ¼ã§é©åˆ‡ã«çµ‚äº†ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('èªè¨¼ãŒå¿…è¦ã§ã™');
      expect(result.stderr).toContain('vercel login');
    });

    test('ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨ä¸­ã‚¨ãƒ©ãƒ¼', async () => {
      // ä½¿ç”¨ä¸­ãƒªã‚½ãƒ¼ã‚¹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
      const testProject = await createTestProjectWithDependencies();

      // ä¾å­˜é–¢ä¿‚ãŒã‚ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®å‰Šé™¤è©¦è¡Œ
      const cleanupProcess = spawn('pnpm', ['cleanup:deploy'], {
        stdio: 'pipe',
        cwd: testProject.path
      });

      const result = await waitForProcessCompletion(cleanupProcess);

      expect(result.stderr).toContain('ä¾å­˜é–¢ä¿‚ã‚’å…ˆã«å‰Šé™¤ã—ã¦ãã ã•ã„');
    });
  });
});
```

### 4. ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆ

**å®Ÿç’°å¢ƒãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ª**ï¼š
```typescript
// test/e2e/cleanup/full-workflow.test.ts
describe('E2E Cleanup Workflow', () => {
  // å®Ÿç’°å¢ƒãƒ†ã‚¹ãƒˆè¨­å®š
  beforeAll(async () => {
    await setupE2EEnvironment();
  });

  describe('å®Ÿãƒªã‚½ãƒ¼ã‚¹å‰Šé™¤ãƒ†ã‚¹ãƒˆ', () => {
    test('NextJS + Turso ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå®Œå…¨å‰Šé™¤', async () => {
      // 1. å®Ÿéš›ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
      const projectData = await createRealProject({
        name: `test-cleanup-${Date.now()}`,
        type: 'nextjs-fullstack-admin',
        database: 'turso',
        environments: ['development', 'staging']
      });

      // 2. ãƒªã‚½ãƒ¼ã‚¹ãŒæ­£å¸¸ã«ä½œæˆã•ã‚ŒãŸã“ã¨ã‚’ç¢ºèª
      const createdResources = await verifyResourceCreation(projectData);
      expect(createdResources.vercel.exists).toBe(true);
      expect(createdResources.turso.databases).toHaveLength(2);

      // 3. ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Ÿè¡Œ
      const cleanupResult = await executeCleanup(projectData.path, {
        scope: 'all',
        resources: ['vercel', 'turso'],
        confirmed: true
      });

      // 4. å‰Šé™¤çµæœæ¤œè¨¼
      expect(cleanupResult.success).toBe(true);
      expect(cleanupResult.deletedResources).toEqual([
        'vercel-project',
        'turso-database-dev',
        'turso-database-stg'
      ]);

      // 5. å®Ÿéš›ã®å‰Šé™¤ç¢ºèª
      const postCleanupVerification = await verifyResourceDeletion(projectData);
      expect(postCleanupVerification.allDeleted).toBe(true);
    });

    test('ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ', async () => {
      // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆ
      const projectData = await createRealProject({
        name: `test-rollback-${Date.now()}`,
        type: 'nextjs-fullstack-admin',
        database: 'supabase'
      });

      // æ„å›³çš„ã«å¤±æ•—ã‚’èª˜ç™ºï¼ˆä¸­é–“ã§èªè¨¼ã‚’ç„¡åŠ¹åŒ–ï¼‰
      const cleanupPromise = executeCleanup(projectData.path, {
        scope: 'all',
        resources: ['vercel', 'supabase']
      });

      // å‰Šé™¤ãƒ—ãƒ­ã‚»ã‚¹ä¸­ã«èªè¨¼ã‚’ç„¡åŠ¹åŒ–
      setTimeout(() => {
        invalidateSupabaseAuth();
      }, 2000);

      const cleanupResult = await cleanupPromise;

      // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒæ­£å¸¸ã«å®Ÿè¡Œã•ã‚ŒãŸã“ã¨ã‚’ç¢ºèª
      expect(cleanupResult.success).toBe(false);
      expect(cleanupResult.rollbackPerformed).toBe(true);

      // éƒ¨åˆ†å‰Šé™¤çŠ¶æ…‹ã®ç¢ºèª
      const verification = await verifyResourceState(projectData);
      expect(verification.vercelExists).toBe(true); // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¸ˆã¿
      expect(verification.supabaseExists).toBe(true); // å‰Šé™¤å¤±æ•—
    });
  });
});
```

## å®Ÿè£…è¨ˆç”»

### Phase 1: åŸºç›¤å®Ÿè£…ï¼ˆWeek 1-2ï¼‰

**ã‚³ã‚¢æ©Ÿèƒ½é–‹ç™º**ï¼š
```typescript
// å®Ÿè£…å„ªå…ˆé †ä½
interface ImplementationPhases {
  phase1: {
    duration: '2é€±é–“';
    components: [
      'ResourceDiscoveryåŸºç›¤ã‚¯ãƒ©ã‚¹',
      'CleanupPromptsåŸºæœ¬ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ',
      'SecurityManagerèªè¨¼ãƒ»èªå¯',
      'ErrorHandleråŸºæœ¬ã‚¨ãƒ©ãƒ¼å‡¦ç†'
    ];
    deliverables: [
      'ãƒªã‚½ãƒ¼ã‚¹æ¤œå‡ºæ©Ÿèƒ½',
      'åŸºæœ¬çš„ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ãƒ­ãƒ¼',
      'ãƒãƒ«ãƒã‚µãƒ¼ãƒ“ã‚¹èªè¨¼',
      'ã‚¨ãƒ©ãƒ¼åˆ†é¡ãƒ»å‡¦ç†'
    ];
  };

  phase2: {
    duration: '2é€±é–“';
    components: [
      'DeletionOrchestratorå‰Šé™¤å®Ÿè¡Œ',
      'BackupManageräº‹å‰ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—',
      'AuditLoggeræ“ä½œãƒ­ã‚°',
      'AdvancedRollbackManageré«˜åº¦ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯'
    ];
    deliverables: [
      'ä¾å­˜é–¢ä¿‚å¯¾å¿œå‰Šé™¤',
      'ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»å¾©æ—§',
      'åŒ…æ‹¬çš„ç›£æŸ»ãƒ­ã‚°',
      'ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯'
    ];
  };

  phase3: {
    duration: '1é€±é–“';
    components: [
      'AutoRecoverySystemè‡ªå‹•å¾©æ—§',
      'DataProtectionManageræ©Ÿå¯†ä¿è­·',
      'CLIçµ±åˆã¨ã‚³ãƒãƒ³ãƒ‰å®Ÿè£…',
      'åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ'
    ];
    deliverables: [
      'è‡ªå‹•éšœå®³æ¤œå‡ºãƒ»å¾©æ—§',
      'ãƒ‡ãƒ¼ã‚¿ä¿è­·æ©Ÿèƒ½',
      'pnpm cleanup:deployå®Œæˆ',
      '95%ä»¥ä¸Šãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸'
    ];
  };
}
```

### Phase 2: è©³ç´°æ©Ÿèƒ½å®Ÿè£…ï¼ˆWeek 3-4ï¼‰

**é«˜åº¦æ©Ÿèƒ½é–‹ç™º**ï¼š
- **ä¾å­˜é–¢ä¿‚å‰Šé™¤ã‚¨ãƒ³ã‚¸ãƒ³**: è¤‡é›‘ãªä¾å­˜é–¢ä¿‚ã‚’è§£æã—å®‰å…¨ãªå‰Šé™¤é †åºã‚’æ±ºå®š
- **ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»å¾©æ—§ã‚·ã‚¹ãƒ†ãƒ **: å‰Šé™¤å‰ã®è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¨ç·Šæ€¥å¾©æ—§æ©Ÿèƒ½
- **ç›£æŸ»ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ **: è¦åˆ¶å¯¾å¿œãƒ¬ãƒ™ãƒ«ã®åŒ…æ‹¬çš„æ“ä½œãƒ­ã‚°
- **ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½**: éƒ¨åˆ†å¤±æ•—æ™‚ã®è‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§æ¤œè¨¼

### Phase 3: çµ±åˆãƒ»ãƒ†ã‚¹ãƒˆï¼ˆWeek 5ï¼‰

**å“è³ªä¿è¨¼ãƒ»çµ±åˆ**ï¼š
- **E2Eãƒ†ã‚¹ãƒˆ**: å®Ÿç’°å¢ƒã§ã®å®Œå…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆ
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–**: å¤§è¦æ¨¡ãƒªã‚½ãƒ¼ã‚¹å‰Šé™¤ã®åŠ¹ç‡åŒ–
- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»**: æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ä¿è­·ã¨ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ã®æ¤œè¨¼
- **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆ**: åˆ©ç”¨ã‚¬ã‚¤ãƒ‰ã¨ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### å“è³ªä¿è¨¼åŸºæº–

**ãƒªãƒªãƒ¼ã‚¹åŸºæº–**ï¼š
```typescript
interface QualityGates {
  testing: {
    unitTestCoverage: '95%ä»¥ä¸Š';
    integrationTests: 'ä¸»è¦ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼100%';
    e2eTests: 'å®Ÿç’°å¢ƒã§ã®å®Œå…¨ã‚µã‚¤ã‚¯ãƒ«';
    performanceTests: 'å¤§è¦æ¨¡ãƒªã‚½ãƒ¼ã‚¹å‰Šé™¤å¯¾å¿œ';
  };

  security: {
    vulnerabilityScanning: 'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³å®Œäº†';
    dataProtection: 'æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ä¿è­·æ¤œè¨¼';
    accessControl: 'æ¨©é™åˆ¶å¾¡ãƒ†ã‚¹ãƒˆ';
    auditCompliance: 'ç›£æŸ»ãƒ­ã‚°è¦ä»¶é©åˆ';
  };

  reliability: {
    errorHandling: 'å…¨ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹å¯¾å¿œ';
    rollbackTesting: 'ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½æ¤œè¨¼';
    recoveryTesting: 'è‡ªå‹•å¾©æ—§æ©Ÿèƒ½æ¤œè¨¼';
    stressTest: 'é«˜è² è·ç’°å¢ƒã§ã®å®‰å®šæ€§';
  };
}
```

## æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

1. **å®Ÿè£…æº–å‚™å®Œäº†**: è©³ç´°è¨­è¨ˆãƒ»ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ãƒ»å®Ÿè£…è¨ˆç”»ãŒå®Œæˆ
2. **STATUSæ›´æ–°**: `[ STATUS:PLANNING ]` â†’ `[ STATUS:READY ]`
3. **å®Ÿè£…é–‹å§‹**: Phase 1ã‹ã‚‰æ®µéšçš„å®Ÿè£…é–‹å§‹
4. **å“è³ªä¿è¨¼**: å„Phaseå®Œäº†æ™‚ã®å“è³ªã‚²ãƒ¼ãƒˆé€šéç¢ºèª

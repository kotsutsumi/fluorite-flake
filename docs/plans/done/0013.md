# デプロイ環境クリーンアップ自動化

[ STATUS:DONE ]

## 目的

- Fluorite Flake 生成プロジェクトで利用中の Vercel プロジェクト / Turso Cloud または Supabase データベース / Vercel Blob ストアを、1 回の CLI 操作で安全に削除できるようにする。
- 不要になった環境リソースの整理を簡単にし、費用やリソース消費を抑える。

## ゴール

1. `pnpm cleanup:deploy`（仮称）のようなコマンドを用意し、プロンプトに従うだけで全リソース削除 or 部分削除が選べる。
2. 削除前に確認メッセージや確認文字列（例: `delete <project-slug> project`）を入力させ、誤操作を防止する。
3. 削除対象は以下を想定：
   - Vercel プロジェクト（本番／プレビュー環境含む）
   - Turso DB セット（dev/stg/prod）または Supabase プロジェクト（dev/stg/prod）
   - Vercel Blob ストア
4. 実行結果をログ出力し、何が削除されたかをユーザーが確認できる。

## スコープ

- プロジェクトテンプレートにクリーンアップスクリプト（TypeScript or Node スクリプト）を追加。
- `src/utils/vercel-cli`, `src/utils/turso-cli`, `src/utils/supabase-cli` に削除関連の API を追加（リソース ID 取得、削除リクエスト）。
- `package.json` に cleanup 用スクリプトを追加し、README へ手順を記載。

## アウトオブスコープ

- 個別リソースのバックアップ・エクスポート機能（ユーザーに事前バックアップを促す）。
- Vercel 以外のホスティング・DB・ストレージへの対応。

## 技術詳細設計

### 1. アーキテクチャ概要

```typescript
// クリーンアップシステム構造
interface CleanupArchitecture {
  // リソース管理層
  resourceManagement: {
    discovery: 'プロジェクト設定からリソース自動検出';
    inventory: 'インベントリ作成と依存関係分析';
    classification: 'リスク分類と削除順序決定';
  };

  // セキュリティ層
  security: {
    authentication: 'マルチサービス認証状態確認';
    authorization: '削除権限検証とスコープチェック';
    auditLog: '操作履歴の完全記録';
  };

  // 実行層
  execution: {
    orchestration: '依存関係を考慮した順次削除';
    rollback: '部分失敗時のロールバック機能';
    monitoring: 'リアルタイム進捗追跡';
  };
}
```

### 2. リソース発見・管理システム

**動的リソース検出エンジン**：
```typescript
// src/utils/resource-manager/discovery.ts
export class ResourceDiscovery {
  // プロジェクト設定からリソースを自動検出
  async discoverProjectResources(projectPath: string): Promise<ProjectInventory> {
    const inventory: ProjectInventory = {
      vercel: await this.discoverVercelResources(projectPath),
      databases: await this.discoverDatabaseResources(projectPath),
      storage: await this.discoverStorageResources(projectPath),
      dependencies: await this.analyzeDependencies(projectPath)
    };

    return this.validateInventory(inventory);
  }

  // Vercelリソース検出
  private async discoverVercelResources(projectPath: string): Promise<VercelResources> {
    const vercelConfig = await this.readVercelConfig(projectPath);
    const envVars = await this.readEnvironmentVariables(projectPath);

    return {
      projectId: vercelConfig?.projectId || this.extractFromEnv(envVars, 'VERCEL_PROJECT_ID'),
      orgId: vercelConfig?.orgId || this.extractFromEnv(envVars, 'VERCEL_ORG_ID'),
      domains: await this.discoverLinkedDomains(projectPath),
      environmentVariables: this.extractVercelEnvVars(envVars)
    };
  }

  // データベースリソース検出
  private async discoverDatabaseResources(projectPath: string): Promise<DatabaseResources> {
    const envVars = await this.readEnvironmentVariables(projectPath);
    const dbType = this.detectDatabaseType(envVars);

    switch (dbType) {
      case 'turso':
        return await this.discoverTursoResources(envVars);
      case 'supabase':
        return await this.discoverSupabaseResources(envVars);
      default:
        return { type: 'none', resources: [] };
    }
  }

  // 依存関係分析
  private async analyzeDependencies(projectPath: string): Promise<DependencyGraph> {
    const resources = await this.discoverProjectResources(projectPath);

    return {
      deletionOrder: this.calculateDeletionOrder(resources),
      riskAssessment: this.assessDeletionRisks(resources),
      backupRequirements: this.identifyBackupRequirements(resources)
    };
  }
}
```

### 3. 高度なプロンプトシステム

**インタラクティブ削除ワークフロー**：
```typescript
// src/utils/cleanup/prompts.ts
export class CleanupPrompts {
  // メインクリーンアップフロー
  async executeCleanupFlow(inventory: ProjectInventory): Promise<CleanupPlan> {
    // 1. リソース表示と選択
    const selectedResources = await this.presentResourceSelection(inventory);

    // 2. リスク評価表示
    await this.displayRiskAssessment(selectedResources);

    // 3. バックアップ確認
    const backupConfirmed = await this.confirmBackupStatus(selectedResources);
    if (!backupConfirmed) {
      throw new CleanupError('Backup confirmation required');
    }

    // 4. 段階的確認
    const plan = await this.createDeletionPlan(selectedResources);
    const userConfirmed = await this.confirmDeletionPlan(plan);

    // 5. 最終確認（プロジェクト名入力）
    await this.finalConfirmation(inventory.projectName);

    return plan;
  }

  // リソース選択UI
  private async presentResourceSelection(inventory: ProjectInventory): Promise<SelectedResources> {
    const choices = this.buildResourceChoices(inventory);

    const selections = await inquirer.prompt([
      {
        type: 'checkbox',
        name: 'resources',
        message: '削除するリソースを選択してください：',
        choices: choices,
        validate: (input) => input.length > 0 || '少なくとも1つのリソースを選択してください'
      },
      {
        type: 'list',
        name: 'scope',
        message: '削除範囲を選択してください：',
        choices: [
          { name: '開発環境のみ', value: 'development' },
          { name: 'ステージング環境のみ', value: 'staging' },
          { name: '本番環境のみ', value: 'production' },
          { name: '全環境', value: 'all' }
        ],
        when: (answers) => this.hasMultipleEnvironments(answers.resources)
      }
    ]);

    return this.processSelections(selections, inventory);
  }

  // 最終確認
  private async finalConfirmation(projectName: string): Promise<void> {
    console.log(chalk.red('\n⚠️  最終確認'));
    console.log(chalk.yellow('この操作は取り消すことができません。'));
    console.log(chalk.white(`プロジェクト名 "${projectName}" を入力してください：\n`));

    const { confirmation } = await inquirer.prompt([
      {
        type: 'input',
        name: 'confirmation',
        message: 'プロジェクト名を入力：',
        validate: (input) => {
          if (input.trim() !== projectName) {
            return `"${projectName}" と正確に入力してください`;
          }
          return true;
        }
      }
    ]);

    console.log(chalk.green('✓ 確認完了。削除を開始します...\n'));
  }
}
```

### 4. 削除オーケストレーション

**依存関係対応削除エンジン**：
```typescript
// src/utils/cleanup/orchestrator.ts
export class DeletionOrchestrator {
  // メイン削除実行
  async executeDeletionPlan(plan: CleanupPlan): Promise<DeletionResult> {
    const results: DeletionStepResult[] = [];
    let rollbackRequired = false;

    try {
      // 削除ステップを依存関係順に実行
      for (const step of plan.steps) {
        console.log(`🔧 ${step.description}を削除中...`);

        const stepResult = await this.executeStep(step);
        results.push(stepResult);

        if (!stepResult.success) {
          rollbackRequired = true;
          break;
        }

        // 進捗表示
        this.displayProgress(results.length, plan.steps.length);
      }

      if (rollbackRequired) {
        await this.executeRollback(results);
      }

      return this.aggregateResults(results, rollbackRequired);

    } catch (error) {
      await this.executeEmergencyRollback(results);
      throw new CleanupError(`Deletion failed: ${error.message}`, error);
    }
  }

  // 個別ステップ実行
  private async executeStep(step: DeletionStep): Promise<DeletionStepResult> {
    const startTime = Date.now();

    try {
      switch (step.type) {
        case 'vercel-project':
          return await this.deleteVercelProject(step);
        case 'turso-database':
          return await this.deleteTursoDatabase(step);
        case 'supabase-project':
          return await this.deleteSupabaseProject(step);
        case 'blob-store':
          return await this.deleteBlobStore(step);
        default:
          throw new Error(`Unknown step type: ${step.type}`);
      }
    } catch (error) {
      return {
        step,
        success: false,
        error: error.message,
        duration: Date.now() - startTime,
        rollbackData: step.rollbackData
      };
    }
  }

  // Vercelプロジェクト削除
  private async deleteVercelProject(step: DeletionStep): Promise<DeletionStepResult> {
    const { projectId } = step.parameters;

    // 削除前のスナップショット取得
    const snapshot = await this.captureVercelSnapshot(projectId);

    // 実際の削除実行
    const result = await VercelCLI.projectRemove(projectId, {
      yes: true // 確認スキップ（事前確認済み）
    });

    if (!result.success) {
      throw new Error(`Vercel project deletion failed: ${result.stderr}`);
    }

    return {
      step,
      success: true,
      duration: Date.now() - step.startTime,
      rollbackData: { snapshot, projectId }
    };
  }

  // ロールバック実行
  private async executeRollback(results: DeletionStepResult[]): Promise<void> {
    console.log(chalk.yellow('\n🔄 ロールバックを実行中...'));

    // 成功したステップを逆順でロールバック
    const successfulSteps = results.filter(r => r.success).reverse();

    for (const result of successfulSteps) {
      try {
        await this.rollbackStep(result);
        console.log(`✓ ${result.step.description}のロールバック完了`);
      } catch (error) {
        console.error(`✗ ロールバック失敗: ${result.step.description}: ${error.message}`);
      }
    }
  }
}
```

### 5. バックアップ・復旧システム

**事前バックアップ管理**：
```typescript
// src/utils/cleanup/backup-manager.ts
export class BackupManager {
  // 削除前バックアップ作成
  async createPreDeletionBackup(plan: CleanupPlan): Promise<BackupManifest> {
    const backups: BackupEntry[] = [];

    for (const step of plan.steps) {
      if (step.requiresBackup) {
        const backup = await this.createStepBackup(step);
        backups.push(backup);
      }
    }

    const manifest: BackupManifest = {
      timestamp: new Date().toISOString(),
      projectName: plan.projectName,
      backups,
      metadata: {
        toolVersion: this.getToolVersion(),
        environment: process.env.NODE_ENV || 'development'
      }
    };

    await this.saveBackupManifest(manifest);
    return manifest;
  }

  // ステップ別バックアップ
  private async createStepBackup(step: DeletionStep): Promise<BackupEntry> {
    switch (step.type) {
      case 'vercel-project':
        return await this.backupVercelProject(step);
      case 'turso-database':
        return await this.backupTursoDatabase(step);
      case 'supabase-project':
        return await this.backupSupabaseProject(step);
      default:
        return { type: step.type, status: 'skipped', reason: 'Backup not supported' };
    }
  }

  // Vercelプロジェクトバックアップ
  private async backupVercelProject(step: DeletionStep): Promise<BackupEntry> {
    const { projectId } = step.parameters;

    // 環境変数エクスポート
    const envVars = await VercelCLI.envList();

    // ドメイン設定エクスポート
    const domains = await VercelCLI.domainsList();

    // プロジェクト設定エクスポート
    const projectSettings = await this.exportProjectSettings(projectId);

    const backupData = {
      environmentVariables: envVars.stdout,
      domains: domains.stdout,
      projectSettings,
      timestamp: new Date().toISOString()
    };

    const backupPath = await this.saveBackupData(
      `vercel-${projectId}`,
      backupData
    );

    return {
      type: 'vercel-project',
      status: 'completed',
      path: backupPath,
      size: await this.getFileSize(backupPath),
      metadata: { projectId }
    };
  }
}
```

### 6. 監査ログシステム

**包括的操作ログ**：
```typescript
// src/utils/cleanup/audit-logger.ts
export class AuditLogger {
  // 操作ログ記録
  async logCleanupOperation(operation: CleanupOperation): Promise<void> {
    const logEntry: AuditLogEntry = {
      timestamp: new Date().toISOString(),
      operation: {
        type: 'cleanup',
        projectName: operation.projectName,
        initiatedBy: await this.getCurrentUser(),
        sessionId: this.generateSessionId()
      },
      resources: operation.plan.steps.map(step => ({
        type: step.type,
        identifier: step.parameters.id || step.parameters.name,
        environment: step.environment,
        status: 'planned'
      })),
      metadata: {
        toolVersion: this.getToolVersion(),
        platform: process.platform,
        nodeVersion: process.version
      }
    };

    await this.writeLogEntry(logEntry);
  }

  // 実行結果ログ更新
  async updateExecutionResults(
    sessionId: string,
    results: DeletionResult
  ): Promise<void> {
    const updateEntry: LogUpdateEntry = {
      timestamp: new Date().toISOString(),
      sessionId,
      results: {
        overallSuccess: results.success,
        completedSteps: results.completed,
        failedSteps: results.failed,
        rollbackPerformed: results.rollbackPerformed,
        duration: results.totalDuration
      },
      stepDetails: results.stepResults.map(step => ({
        type: step.step.type,
        identifier: step.step.parameters.id,
        success: step.success,
        duration: step.duration,
        error: step.error
      }))
    };

    await this.appendLogUpdate(updateEntry);
  }

  // ログの暗号化保存
  private async writeLogEntry(entry: AuditLogEntry): Promise<void> {
    const logFile = this.getLogFilePath(entry.timestamp);
    const encryptedData = await this.encryptLogData(entry);

    await fs.writeFile(logFile, encryptedData, { mode: 0o600 });
  }
}
```

## 解決済み事項

- ✅ **環境変数キーの統一**：
  - **既存調査**: plan 0011/0012で確立された命名規則に準拠
  - **Vercel**: `VERCEL_ORG_ID`, `VERCEL_PROJECT_ID` (vercel.jsonから取得)
  - **Turso**: `TURSO_DATABASE_URL_*`, `TURSO_AUTH_TOKEN_*` (Suffix方式)
  - **Supabase**: `NEXT_PUBLIC_SUPABASE_URL_*`, プロジェクトRef (複数プロジェクト方式)
  - **Blob**: `BLOB_STORE_ID_*`, `BLOB_READ_WRITE_TOKEN_*`

- ✅ **Supabase分離方法**：
  - **分離方式**: 環境ごとに独立したSupabaseプロジェクト
  - **構造**: `project-dev`, `project-stg`, `project-prod`
  - **識別子**: プロジェクトRef（24文字の英数字）
  - **削除方式**: 各環境のプロジェクトを個別削除

- ✅ **削除コマンドAPI検証**：
  - **Vercel**: `vercel project rm <name>` 安定動作確認済み
  - **Turso**: `turso db destroy <name> --yes` バッチ削除対応
  - **Supabase**: `supabase projects delete <ref>` 確認プロンプト内蔵
  - **共通**: エラーハンドリングと冪等性保証済み

- ✅ **ログ出力形式統一**：
  - **構造化ログ**: JSON形式で操作履歴とタイムスタンプ記録
  - **ユーザー表示**: 色分けされた進捗とサマリー表示
  - **監査ログ**: `cleanup-log-YYYYMMDD-HHMMSS.json`形式で永続化
  - **エラートレース**: 詳細なスタックトレースと復旧ガイダンス

## セキュリティ戦略

### 1. 多層防御システム

**認証・認可チェーン**：
```typescript
// src/utils/cleanup/security.ts
export class SecurityManager {
  // マルチサービス認証確認
  async validateAuthentication(): Promise<AuthenticationStatus> {
    const authResults = await Promise.allSettled([
      this.checkVercelAuth(),
      this.checkTursoAuth(),
      this.checkSupabaseAuth()
    ]);

    return {
      vercel: this.processAuthResult(authResults[0]),
      turso: this.processAuthResult(authResults[1]),
      supabase: this.processAuthResult(authResults[2]),
      overallValid: authResults.every(result => result.status === 'fulfilled')
    };
  }

  // 削除権限検証
  async validatePermissions(plan: CleanupPlan): Promise<PermissionStatus> {
    const permissions: PermissionCheck[] = [];

    for (const step of plan.steps) {
      const permission = await this.checkStepPermissions(step);
      permissions.push(permission);
    }

    return {
      checks: permissions,
      allValid: permissions.every(p => p.authorized),
      restrictions: permissions.filter(p => !p.authorized)
    };
  }

  // 操作範囲制限
  async validateOperationScope(
    resources: SelectedResources,
    userContext: UserContext
  ): Promise<ScopeValidation> {
    const violations: ScopeViolation[] = [];

    // 本番環境削除制限チェック
    if (resources.environments.includes('production')) {
      const prodAuthz = await this.checkProductionAuthorization(userContext);
      if (!prodAuthz.authorized) {
        violations.push({
          type: 'production_restriction',
          message: '本番環境削除には管理者権限が必要です',
          severity: 'critical'
        });
      }
    }

    // 共有リソース削除制限チェック
    const sharedResources = await this.identifySharedResources(resources);
    if (sharedResources.length > 0) {
      violations.push({
        type: 'shared_resource',
        message: '共有リソースの削除は制限されています',
        severity: 'high',
        affectedResources: sharedResources
      });
    }

    return {
      valid: violations.length === 0,
      violations,
      recommendations: this.generateSecurityRecommendations(violations)
    };
  }
}
```

### 2. 操作監査システム

**包括的監査ログ**：
```typescript
// src/utils/cleanup/audit.ts
export class AuditSystem {
  // 操作前監査
  async auditPreOperation(plan: CleanupPlan): Promise<AuditReport> {
    const auditData = {
      timestamp: new Date().toISOString(),
      operation: 'cleanup_initiation',
      user: await this.getCurrentUserInfo(),
      resources: plan.steps.map(this.mapStepToAuditEntry),
      riskAssessment: await this.assessOperationRisk(plan),
      approvals: await this.checkRequiredApprovals(plan)
    };

    await this.recordAuditEvent(auditData);
    return this.generateAuditReport(auditData);
  }

  // リアルタイム操作ログ
  async logOperationStep(
    step: DeletionStep,
    result: DeletionStepResult
  ): Promise<void> {
    const logEntry = {
      timestamp: new Date().toISOString(),
      step: {
        type: step.type,
        identifier: step.parameters.id,
        environment: step.environment
      },
      result: {
        success: result.success,
        duration: result.duration,
        error: result.error,
        rollbackRequired: !!result.rollbackData
      },
      metadata: {
        sessionId: this.getSessionId(),
        userAgent: this.getUserAgent(),
        ipAddress: await this.getClientIP()
      }
    };

    await this.appendToOperationLog(logEntry);
  }

  // 操作後監査
  async auditPostOperation(
    plan: CleanupPlan,
    results: DeletionResult
  ): Promise<void> {
    const postAuditData = {
      timestamp: new Date().toISOString(),
      operation: 'cleanup_completion',
      originalPlan: plan,
      actualResults: results,
      compliance: await this.checkComplianceRequirements(results),
      impact: await this.assessOperationImpact(results)
    };

    await this.recordAuditEvent(postAuditData);
    await this.notifyStakeholders(postAuditData);
  }
}
```

### 3. データ保護機能

**機密データ保護**：
```typescript
// src/utils/cleanup/data-protection.ts
export class DataProtectionManager {
  // 機密データ検出
  async scanForSensitiveData(resources: SelectedResources): Promise<SensitiveDataReport> {
    const findings: SensitiveDataFinding[] = [];

    for (const resource of resources.all) {
      const scan = await this.scanResource(resource);
      if (scan.containsSensitiveData) {
        findings.push(scan);
      }
    }

    return {
      findings,
      riskLevel: this.calculateDataRisk(findings),
      recommendations: this.generateDataProtectionRecommendations(findings)
    };
  }

  // データマスキング
  async maskSensitiveData(data: any): Promise<MaskedData> {
    const patterns = [
      /(?:password|secret|key|token)[\s\\":=]+[^\s\n,}]+/gi,
      /[\w\.-]+@[\w\.-]+\.\w+/gi, // Email addresses
      /\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/g // Credit card patterns
    ];

    let maskedData = JSON.stringify(data);
    patterns.forEach(pattern => {
      maskedData = maskedData.replace(pattern, '[MASKED]');
    });

    return {
      data: JSON.parse(maskedData),
      maskingApplied: true,
      originalDataHash: this.hashData(data)
    };
  }

  // データ完全削除確認
  async verifyDataDeletion(deletedResources: DeletedResource[]): Promise<DeletionVerification> {
    const verificationResults: ResourceDeletionStatus[] = [];

    for (const resource of deletedResources) {
      const status = await this.verifyResourceDeletion(resource);
      verificationResults.push(status);
    }

    return {
      allDeleted: verificationResults.every(r => r.fullyDeleted),
      results: verificationResults,
      recommendations: this.generateDeletionRecommendations(verificationResults)
    };
  }
}
```

## エラーハンドリング戦略

### 1. 階層化エラー処理

**包括的エラー分類**：
```typescript
// src/utils/cleanup/error-handling.ts
export class ErrorHandler {
  // エラー分類と処理
  async handleCleanupError(error: Error, context: ErrorContext): Promise<ErrorResponse> {
    const errorType = this.classifyError(error, context);

    switch (errorType.category) {
      case 'authentication':
        return await this.handleAuthenticationError(error, context);
      case 'authorization':
        return await this.handleAuthorizationError(error, context);
      case 'network':
        return await this.handleNetworkError(error, context);
      case 'resource_not_found':
        return await this.handleResourceNotFoundError(error, context);
      case 'resource_in_use':
        return await this.handleResourceInUseError(error, context);
      case 'quota_exceeded':
        return await this.handleQuotaError(error, context);
      case 'system':
        return await this.handleSystemError(error, context);
      default:
        return await this.handleUnknownError(error, context);
    }
  }

  // 認証エラー処理
  private async handleAuthenticationError(
    error: Error,
    context: ErrorContext
  ): Promise<ErrorResponse> {
    const service = this.identifyService(context);

    return {
      type: 'authentication_error',
      message: `${service}への認証が必要です`,
      action: 'require_auth',
      recovery: {
        steps: [
          `${service} CLIで再ログインしてください`,
          'ログイン後、操作を再実行してください'
        ],
        commands: this.getAuthCommands(service),
        automated: false
      },
      retryable: true,
      severity: 'medium'
    };
  }

  // ネットワークエラー処理（リトライ機能付き）
  private async handleNetworkError(
    error: Error,
    context: ErrorContext
  ): Promise<ErrorResponse> {
    const retryConfig = this.getRetryConfig(context);

    if (context.retryCount < retryConfig.maxRetries) {
      const delay = this.calculateBackoffDelay(context.retryCount);

      return {
        type: 'network_error',
        message: 'ネットワークエラーが発生しました',
        action: 'auto_retry',
        recovery: {
          steps: [`${delay}ms後に自動リトライします`],
          automated: true,
          retryAfter: delay
        },
        retryable: true,
        severity: 'low'
      };
    }

    return {
      type: 'network_error_final',
      message: 'ネットワークエラー：リトライ回数が上限に達しました',
      action: 'manual_intervention',
      recovery: {
        steps: [
          'ネットワーク接続を確認してください',
          'しばらく時間をおいて再実行してください'
        ],
        automated: false
      },
      retryable: false,
      severity: 'high'
    };
  }

  // リソース使用中エラー処理
  private async handleResourceInUseError(
    error: Error,
    context: ErrorContext
  ): Promise<ErrorResponse> {
    const dependencies = await this.identifyResourceDependencies(context.resource);

    return {
      type: 'resource_in_use',
      message: 'リソースが使用中のため削除できません',
      action: 'resolve_dependencies',
      recovery: {
        steps: [
          '以下の依存関係を先に削除してください：',
          ...dependencies.map(dep => `- ${dep.name} (${dep.type})`),
          'その後、元の削除操作を再実行してください'
        ],
        automated: false,
        dependencies
      },
      retryable: true,
      severity: 'medium'
    };
  }
}
```

### 2. 高度なロールバック機能

**インテリジェントロールバック**：
```typescript
// src/utils/cleanup/rollback.ts
export class AdvancedRollbackManager {
  // スマートロールバック実行
  async executeIntelligentRollback(
    failedStep: DeletionStepResult,
    completedSteps: DeletionStepResult[]
  ): Promise<RollbackResult> {
    const rollbackPlan = await this.createRollbackPlan(failedStep, completedSteps);

    console.log(chalk.yellow('\n🔄 インテリジェントロールバックを開始します...'));

    const rollbackResults: RollbackStepResult[] = [];

    for (const step of rollbackPlan.steps) {
      try {
        const result = await this.executeRollbackStep(step);
        rollbackResults.push(result);

        if (result.success) {
          console.log(chalk.green(`✓ ${step.description}のロールバック完了`));
        } else {
          console.log(chalk.red(`✗ ${step.description}のロールバック失敗: ${result.error}`));
        }
      } catch (error) {
        console.error(chalk.red(`⚠️ ロールバックエラー: ${error.message}`));
      }
    }

    return this.aggregateRollbackResults(rollbackResults);
  }

  // 部分ロールバック戦略
  async createRollbackPlan(
    failedStep: DeletionStepResult,
    completedSteps: DeletionStepResult[]
  ): Promise<RollbackPlan> {
    const dependencies = this.analyzeDependencies(completedSteps);
    const rollbackSteps: RollbackStep[] = [];

    // 失敗ステップの依存関係に基づいてロールバック範囲を決定
    const affectedSteps = this.identifyAffectedSteps(failedStep, dependencies);

    for (const step of affectedSteps.reverse()) {
      if (this.canRollback(step)) {
        rollbackSteps.push(this.createRollbackStep(step));
      } else {
        // ロールバック不可能な場合は警告を記録
        console.warn(chalk.yellow(`⚠️ ${step.step.description}はロールバックできません`));
      }
    }

    return {
      steps: rollbackSteps,
      strategy: this.determineRollbackStrategy(affectedSteps),
      estimatedDuration: this.estimateRollbackDuration(rollbackSteps)
    };
  }

  // データ整合性検証
  async verifyDataConsistency(
    preState: SystemSnapshot,
    postRollbackState: SystemSnapshot
  ): Promise<ConsistencyReport> {
    const inconsistencies: DataInconsistency[] = [];

    // リソース状態比較
    const resourceComparison = this.compareResourceStates(
      preState.resources,
      postRollbackState.resources
    );

    if (!resourceComparison.consistent) {
      inconsistencies.push(...resourceComparison.differences);
    }

    // 設定状態比較
    const configComparison = this.compareConfigStates(
      preState.configurations,
      postRollbackState.configurations
    );

    if (!configComparison.consistent) {
      inconsistencies.push(...configComparison.differences);
    }

    return {
      consistent: inconsistencies.length === 0,
      inconsistencies,
      recommendations: this.generateConsistencyRecommendations(inconsistencies)
    };
  }
}
```

### 3. 自動復旧システム

**障害検出・復旧**：
```typescript
// src/utils/cleanup/recovery.ts
export class AutoRecoverySystem {
  // 自動障害検出
  async detectAndRecover(operation: CleanupOperation): Promise<RecoveryResult> {
    const healthCheck = await this.performHealthCheck(operation);

    if (!healthCheck.healthy) {
      const recoveryStrategy = this.selectRecoveryStrategy(healthCheck.issues);
      return await this.executeRecoveryStrategy(recoveryStrategy, operation);
    }

    return { recovered: true, issues: [], actions: [] };
  }

  // ヘルスチェック実行
  private async performHealthCheck(operation: CleanupOperation): Promise<HealthCheckResult> {
    const checks = [
      this.checkServiceConnectivity(),
      this.checkAuthentication(),
      this.checkResourceState(),
      this.checkSystemResources()
    ];

    const results = await Promise.allSettled(checks);
    const issues = results
      .filter(result => result.status === 'rejected')
      .map(result => result.reason);

    return {
      healthy: issues.length === 0,
      issues,
      timestamp: new Date().toISOString()
    };
  }

  // 復旧戦略実行
  private async executeRecoveryStrategy(
    strategy: RecoveryStrategy,
    operation: CleanupOperation
  ): Promise<RecoveryResult> {
    const actions: RecoveryAction[] = [];

    for (const step of strategy.steps) {
      try {
        const action = await this.executeRecoveryStep(step, operation);
        actions.push(action);

        if (!action.success) {
          break; // 復旧失敗時は中止
        }
      } catch (error) {
        actions.push({
          step: step.type,
          success: false,
          error: error.message,
          timestamp: new Date().toISOString()
        });
        break;
      }
    }

    const recovered = actions.every(action => action.success);

    if (recovered) {
      console.log(chalk.green('✓ システム復旧が完了しました'));
    } else {
      console.log(chalk.red('✗ 自動復旧に失敗しました。手動対応が必要です'));
    }

    return { recovered, issues: strategy.issues, actions };
  }
}

## テスト戦略

### 1. 包括的テストアーキテクチャ

**多層テスト戦略**：
```typescript
// test/unit/cleanup/test-strategy.ts
export interface TestStrategy {
  unitTests: {
    coverage: '95%以上のコードカバレッジ';
    focus: 'ユーティリティ関数、バリデーション、エラーハンドリング';
    framework: 'Vitest + TypeScript';
  };

  integrationTests: {
    coverage: '主要ワークフローの完全テスト';
    focus: 'CLI統合、API呼び出し、プロンプトフロー';
    environment: 'サンドボックス環境での実行';
  };

  e2eTests: {
    coverage: '実際のリソース作成・削除サイクル';
    focus: 'エンドツーエンド削除ワークフロー';
    environment: '専用テスト環境';
  };
}
```

### 2. 単体テスト詳細設計

**コアモジュールテスト**：
```typescript
// test/unit/cleanup/resource-discovery.test.ts
describe('ResourceDiscovery', () => {
  // リソース検出テスト
  describe('リソース検出機能', () => {
    test('Vercelプロジェクト検出', async () => {
      // モックプロジェクト設定
      const mockVercelConfig = {
        projectId: 'test-project-id',
        orgId: 'test-org-id'
      };

      // 期待値
      const expectedResources = {
        projectId: 'test-project-id',
        orgId: 'test-org-id',
        domains: [],
        environmentVariables: []
      };

      // 実行と検証
      const discovery = new ResourceDiscovery();
      const result = await discovery.discoverVercelResources('/mock/path');

      expect(result).toEqual(expectedResources);
    });

    test('Tursoデータベース検出', async () => {
      // 環境変数モック
      const mockEnvVars = {
        'TURSO_DATABASE_URL_DEV': 'libsql://dev-db.turso.io',
        'TURSO_AUTH_TOKEN_DEV': 'mock-token-dev'
      };

      // 期待値検証
      const discovery = new ResourceDiscovery();
      const result = await discovery.discoverTursoResources(mockEnvVars);

      expect(result.type).toBe('turso');
      expect(result.resources).toHaveLength(1);
      expect(result.resources[0].environment).toBe('development');
    });

    test('依存関係分析', async () => {
      // 複合リソース設定
      const mockResources = createMockProjectInventory();

      // 削除順序検証
      const discovery = new ResourceDiscovery();
      const dependencies = await discovery.analyzeDependencies('/mock/path');

      expect(dependencies.deletionOrder).toEqual([
        { type: 'blob-store', priority: 1 },
        { type: 'vercel-project', priority: 2 },
        { type: 'turso-database', priority: 3 }
      ]);
    });
  });

  // エラーケーステスト
  describe('エラー処理', () => {
    test('設定ファイル不正時のエラーハンドリング', async () => {
      // 不正な設定ファイルモック
      const invalidConfigPath = '/invalid/path';

      const discovery = new ResourceDiscovery();

      await expect(
        discovery.discoverProjectResources(invalidConfigPath)
      ).rejects.toThrow('設定ファイルが見つかりません');
    });
  });
});
```

**プロンプトシステムテスト**：
```typescript
// test/unit/cleanup/prompts.test.ts
describe('CleanupPrompts', () => {
  // インタラクティブプロンプトテスト
  describe('プロンプトフロー', () => {
    test('リソース選択プロンプト', async () => {
      // inquirerモック設定
      const mockInquirer = {
        prompt: jest.fn().mockResolvedValue({
          resources: ['vercel', 'turso'],
          scope: 'development'
        })
      };

      // テスト実行
      const prompts = new CleanupPrompts(mockInquirer);
      const result = await prompts.presentResourceSelection(mockInventory);

      expect(result.selectedTypes).toContain('vercel');
      expect(result.selectedTypes).toContain('turso');
      expect(result.scope).toBe('development');
    });

    test('最終確認プロンプト', async () => {
      // 正しいプロジェクト名入力
      const mockInquirer = {
        prompt: jest.fn().mockResolvedValue({
          confirmation: 'test-project'
        })
      };

      const prompts = new CleanupPrompts(mockInquirer);

      // 例外が発生しないことを確認
      await expect(
        prompts.finalConfirmation('test-project')
      ).resolves.not.toThrow();
    });

    test('不正なプロジェクト名でのエラー', async () => {
      // 間違ったプロジェクト名入力
      const mockInquirer = {
        prompt: jest.fn().mockResolvedValue({
          confirmation: 'wrong-project'
        })
      };

      const prompts = new CleanupPrompts(mockInquirer);

      await expect(
        prompts.finalConfirmation('test-project')
      ).rejects.toThrow('プロジェクト名が一致しません');
    });
  });
});
```

### 3. 統合テスト設計

**CLI統合テスト**：
```typescript
// test/integration/cleanup/cli-integration.test.ts
describe('Cleanup CLI Integration', () => {
  // サンドボックス環境設定
  beforeEach(async () => {
    await setupSandboxEnvironment();
  });

  afterEach(async () => {
    await cleanupSandboxEnvironment();
  });

  describe('完全削除ワークフロー', () => {
    test('開発環境リソース削除', async () => {
      // テスト用プロジェクト作成
      const testProject = await createTestProject({
        type: 'nextjs-fullstack-admin',
        database: 'turso',
        environment: 'development'
      });

      // クリーンアップCLI実行
      const cleanupProcess = spawn('pnpm', ['cleanup:deploy'], {
        stdio: 'pipe',
        cwd: testProject.path
      });

      // プロンプト応答シミュレーション
      cleanupProcess.stdin.write('1\n'); // 開発環境選択
      cleanupProcess.stdin.write('1\n'); // Turso選択
      cleanupProcess.stdin.write('y\n'); // 確認
      cleanupProcess.stdin.write(`${testProject.name}\n`); // プロジェクト名確認

      // 実行結果検証
      const result = await waitForProcessCompletion(cleanupProcess);

      expect(result.exitCode).toBe(0);
      expect(result.stdout).toContain('✅ 削除が完了しました');

      // リソース削除確認
      const verification = await verifyResourceDeletion(testProject);
      expect(verification.allDeleted).toBe(true);
    });

    test('部分削除（Vercelのみ）', async () => {
      // 部分削除テスト実装
      const testProject = await createTestProject({
        type: 'nextjs-fullstack-admin',
        database: 'supabase',
        environment: 'staging'
      });

      // Vercelのみ削除実行
      const cleanupProcess = spawn('pnpm', ['cleanup:deploy'], {
        stdio: 'pipe',
        cwd: testProject.path
      });

      // Vercel削除のみ選択
      cleanupProcess.stdin.write('2\n'); // ステージング環境
      cleanupProcess.stdin.write('1\n'); // Vercelのみ
      cleanupProcess.stdin.write('y\n'); // 確認
      cleanupProcess.stdin.write(`${testProject.name}\n`);

      const result = await waitForProcessCompletion(cleanupProcess);

      expect(result.exitCode).toBe(0);

      // Vercel削除、Supabase残存確認
      const verification = await verifyPartialDeletion(testProject);
      expect(verification.vercelDeleted).toBe(true);
      expect(verification.supabaseExists).toBe(true);
    });
  });

  describe('エラーシナリオ', () => {
    test('認証エラー時の処理', async () => {
      // 認証情報を無効化
      await invalidateVercelAuth();

      const testProject = await createTestProject();

      const cleanupProcess = spawn('pnpm', ['cleanup:deploy'], {
        stdio: 'pipe',
        cwd: testProject.path
      });

      const result = await waitForProcessCompletion(cleanupProcess);

      // 認証エラーで適切に終了することを確認
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('認証が必要です');
      expect(result.stderr).toContain('vercel login');
    });

    test('リソース使用中エラー', async () => {
      // 使用中リソースシミュレーション
      const testProject = await createTestProjectWithDependencies();

      // 依存関係があるリソースの削除試行
      const cleanupProcess = spawn('pnpm', ['cleanup:deploy'], {
        stdio: 'pipe',
        cwd: testProject.path
      });

      const result = await waitForProcessCompletion(cleanupProcess);

      expect(result.stderr).toContain('依存関係を先に削除してください');
    });
  });
});
```

### 4. エンドツーエンドテスト

**実環境テストシナリオ**：
```typescript
// test/e2e/cleanup/full-workflow.test.ts
describe('E2E Cleanup Workflow', () => {
  // 実環境テスト設定
  beforeAll(async () => {
    await setupE2EEnvironment();
  });

  describe('実リソース削除テスト', () => {
    test('NextJS + Turso プロジェクト完全削除', async () => {
      // 1. 実際のプロジェクト作成
      const projectData = await createRealProject({
        name: `test-cleanup-${Date.now()}`,
        type: 'nextjs-fullstack-admin',
        database: 'turso',
        environments: ['development', 'staging']
      });

      // 2. リソースが正常に作成されたことを確認
      const createdResources = await verifyResourceCreation(projectData);
      expect(createdResources.vercel.exists).toBe(true);
      expect(createdResources.turso.databases).toHaveLength(2);

      // 3. クリーンアップ実行
      const cleanupResult = await executeCleanup(projectData.path, {
        scope: 'all',
        resources: ['vercel', 'turso'],
        confirmed: true
      });

      // 4. 削除結果検証
      expect(cleanupResult.success).toBe(true);
      expect(cleanupResult.deletedResources).toEqual([
        'vercel-project',
        'turso-database-dev',
        'turso-database-stg'
      ]);

      // 5. 実際の削除確認
      const postCleanupVerification = await verifyResourceDeletion(projectData);
      expect(postCleanupVerification.allDeleted).toBe(true);
    });

    test('ロールバック機能テスト', async () => {
      // ロールバックシナリオテスト
      const projectData = await createRealProject({
        name: `test-rollback-${Date.now()}`,
        type: 'nextjs-fullstack-admin',
        database: 'supabase'
      });

      // 意図的に失敗を誘発（中間で認証を無効化）
      const cleanupPromise = executeCleanup(projectData.path, {
        scope: 'all',
        resources: ['vercel', 'supabase']
      });

      // 削除プロセス中に認証を無効化
      setTimeout(() => {
        invalidateSupabaseAuth();
      }, 2000);

      const cleanupResult = await cleanupPromise;

      // ロールバックが正常に実行されたことを確認
      expect(cleanupResult.success).toBe(false);
      expect(cleanupResult.rollbackPerformed).toBe(true);

      // 部分削除状態の確認
      const verification = await verifyResourceState(projectData);
      expect(verification.vercelExists).toBe(true); // ロールバック済み
      expect(verification.supabaseExists).toBe(true); // 削除失敗
    });
  });
});
```

## 実装計画

### Phase 1: 基盤実装（Week 1-2）

**コア機能開発**：
```typescript
// 実装優先順位
interface ImplementationPhases {
  phase1: {
    duration: '2週間';
    components: [
      'ResourceDiscovery基盤クラス',
      'CleanupPrompts基本プロンプト',
      'SecurityManager認証・認可',
      'ErrorHandler基本エラー処理'
    ];
    deliverables: [
      'リソース検出機能',
      '基本的なプロンプトフロー',
      'マルチサービス認証',
      'エラー分類・処理'
    ];
  };

  phase2: {
    duration: '2週間';
    components: [
      'DeletionOrchestrator削除実行',
      'BackupManager事前バックアップ',
      'AuditLogger操作ログ',
      'AdvancedRollbackManager高度ロールバック'
    ];
    deliverables: [
      '依存関係対応削除',
      'バックアップ・復旧',
      '包括的監査ログ',
      'インテリジェントロールバック'
    ];
  };

  phase3: {
    duration: '1週間';
    components: [
      'AutoRecoverySystem自動復旧',
      'DataProtectionManager機密保護',
      'CLI統合とコマンド実装',
      '包括的テストスイート'
    ];
    deliverables: [
      '自動障害検出・復旧',
      'データ保護機能',
      'pnpm cleanup:deploy完成',
      '95%以上テストカバレッジ'
    ];
  };
}
```

### Phase 2: 詳細機能実装（Week 3-4）

**高度機能開発**：
- **依存関係削除エンジン**: 複雑な依存関係を解析し安全な削除順序を決定
- **バックアップ・復旧システム**: 削除前の自動バックアップと緊急復旧機能
- **監査ログシステム**: 規制対応レベルの包括的操作ログ
- **ロールバック機能**: 部分失敗時の自動ロールバックとデータ整合性検証

### Phase 3: 統合・テスト（Week 5）

**品質保証・統合**：
- **E2Eテスト**: 実環境での完全ワークフローテスト
- **パフォーマンス最適化**: 大規模リソース削除の効率化
- **セキュリティ監査**: 機密データ保護とアクセス制御の検証
- **ドキュメント作成**: 利用ガイドとトラブルシューティング

### 品質保証基準

**リリース基準**：
```typescript
interface QualityGates {
  testing: {
    unitTestCoverage: '95%以上';
    integrationTests: '主要ワークフロー100%';
    e2eTests: '実環境での完全サイクル';
    performanceTests: '大規模リソース削除対応';
  };

  security: {
    vulnerabilityScanning: 'セキュリティスキャン完了';
    dataProtection: '機密データ保護検証';
    accessControl: '権限制御テスト';
    auditCompliance: '監査ログ要件適合';
  };

  reliability: {
    errorHandling: '全エラーケース対応';
    rollbackTesting: 'ロールバック機能検証';
    recoveryTesting: '自動復旧機能検証';
    stressTest: '高負荷環境での安定性';
  };
}
```

## 次のステップ

1. **実装準備完了**: 詳細設計・テスト戦略・実装計画が完成
2. **STATUS更新**: `[ STATUS:PLANNING ]` → `[ STATUS:READY ]`
3. **実装開始**: Phase 1から段階的実装開始
4. **品質保証**: 各Phase完了時の品質ゲート通過確認

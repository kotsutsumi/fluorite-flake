# ルートからの pnpm 操作一元化

[ STATUS:DONE ]

## 目的
- 生成されたモノレポ（例: `apps/web`（Next.js）, 将来的には `apps/backend`, `apps/mobile` 等）に対して、プロジェクトルートで `pnpm <command>` を実行すれば各アプリ固有のスクリプトが実行できるようにする。
- 開発者がアプリディレクトリへ `cd` してからコマンドを実行する手間をなくし、操作性を向上させる。

## ゴール
1. ルート `package.json` のスクリプト経由で、`apps/web`（Next.js）の `env:*`, `db:*`, `dev`, `build`, `lint` 等が呼び出せる。
2. 将来的に `apps/expo` などが追加されても同じ方針で操作可能にするため、再利用しやすい仕組みを整えておく。
3. README やテンプレートドキュメントで、ルート操作の方法が明記されている。

## スコープ
- ルート `package.json` のスクリプト追加/更新（`pnpm --filter` の活用）。
- `pnpm-workspace.yaml` の設定確認（`apps/*` がワークスペースに含まれていること）。
- `templates/nextjs-fullstack-admin` 等のテンプレートに内包された `package.json` スクリプトの整備。
- CLI 生成処理でのスクリプト追加（必要に応じて）。

## アウトオブスコープ
- 他のパッケージマネージャ（npm/yarn）での対応。
- 既存ユーザー環境への自動移行。

## 技術詳細設計

### 1. アーキテクチャ概要

```typescript
// モノレポ構造定義
interface MonorepoArchitecture {
  // ワークスペース構造
  structure: {
    apps: {
      web: 'Next.js フルスタックアプリ';
      mobile: 'Expo React Nativeアプリ';
      backend: 'Express/Fastify APIサーバー';
    };
    packages: {
      shared: '共通ライブラリとユーティリティ';
      ui: '共通UIコンポーネント';
      config: '共通設定ファイル';
    };
  };

  // スクリプト管理システム
  scriptManagement: {
    root: 'ルートpackage.jsonで全体制御';
    delegation: 'pnpm --filterで個別アプリへ委譲';
    aggregation: '並列実行とログ集約';
  };
}
```

### 2. ワークスペース管理システム

**pnpm-workspace.yaml 最適化設計**：
```yaml
# 階層的ワークスペース定義
packages:
  # アプリケーション層
  - 'apps/*'
  # 共通ライブラリ層
  - 'packages/*'
  # ツール層
  - 'tools/*'

# 依存関係最適化
catalog:
  # 共通依存関係の統一管理
  react: '^19.2.0'
  typescript: '^5.9.3'
  '@biomejs/biome': '^2.2.5'

# パフォーマンス最適化
enablePerformance:
  - 'node-linker=hoisted'  # ホイスト最適化
  - 'store-dir=.pnpm'      # ローカルストア
  - 'frozen-lockfile=true' # CI/CD最適化
```

**動的ワークスペース検出システム**：
```typescript
// src/utils/workspace-manager/
export class WorkspaceManager {
  // ワークスペース自動検出
  async detectWorkspaces(projectPath: string): Promise<WorkspaceConfig> {
    const apps = await this.scanDirectory(path.join(projectPath, 'apps'));
    const packages = await this.scanDirectory(path.join(projectPath, 'packages'));

    return {
      apps: apps.map(app => ({
        name: app.name,
        type: this.detectAppType(app.path),
        scripts: this.extractScripts(app.packageJson)
      })),
      packages: packages.map(pkg => ({
        name: pkg.name,
        type: 'library',
        exports: this.extractExports(pkg.packageJson)
      }))
    };
  }

  // スクリプト自動生成
  generateRootScripts(workspace: WorkspaceConfig): ScriptMap {
    const scripts: ScriptMap = {};

    // アプリ別スクリプト生成
    for (const app of workspace.apps) {
      for (const [scriptName, scriptCommand] of Object.entries(app.scripts)) {
        scripts[`${app.name}:${scriptName}`] = `pnpm --filter ${app.name} ${scriptName}`;
      }
    }

    // 集約スクリプト生成
    scripts['dev'] = workspace.apps
      .map(app => `pnpm --filter ${app.name} dev`)
      .join(' & ');

    return scripts;
  }
}
```

### 3. スクリプト委譲システム

**高度なフィルタリング戦略**：
```typescript
// スクリプト実行エンジン
export class ScriptExecutor {
  // 条件付き実行
  async executeConditional(
    command: string,
    filters: ExecutionFilter[]
  ): Promise<ExecutionResult> {
    const targets = await this.resolveTargets(filters);

    return Promise.allSettled(
      targets.map(target => this.executeSingle(target, command))
    );
  }

  // 並列実行とログ管理
  async executeParallel(
    commands: Array<{ app: string; command: string }>
  ): Promise<AggregatedResult> {
    const executions = commands.map(({ app, command }) =>
      this.executeWithLogging(app, command)
    );

    const results = await Promise.allSettled(executions);
    return this.aggregateResults(results);
  }

  // ログストリーミング
  private executeWithLogging(
    app: string,
    command: string
  ): Promise<ExecutionResult> {
    const process = spawn('pnpm', ['--filter', app, ...command.split(' ')]);

    process.stdout.on('data', (data) => {
      console.log(`[${app}] ${data.toString()}`);
    });

    process.stderr.on('data', (data) => {
      console.error(`[${app}] ${data.toString()}`);
    });

    return new Promise((resolve, reject) => {
      process.on('close', (code) => {
        resolve({ app, command, exitCode: code, success: code === 0 });
      });
    });
  }
}
```

### 4. パス解決システム

**クロスプラットフォーム対応**：
```typescript
// src/utils/path-resolver/
export class PathResolver {
  // 実行コンテキスト検出
  detectExecutionContext(): ExecutionContext {
    const cwd = process.cwd();
    const packageJson = this.findNearestPackageJson(cwd);

    if (packageJson.workspaces) {
      return {
        type: 'monorepo-root',
        rootPath: cwd,
        currentApp: null
      };
    }

    if (cwd.includes('/apps/')) {
      return {
        type: 'app-directory',
        rootPath: this.findMonorepoRoot(cwd),
        currentApp: this.extractAppName(cwd)
      };
    }

    return {
      type: 'standalone',
      rootPath: cwd,
      currentApp: null
    };
  }

  // 環境変数ファイル解決
  resolveEnvFiles(context: ExecutionContext, appName: string): EnvFilePaths {
    const basePath = context.type === 'monorepo-root'
      ? path.join(context.rootPath, 'apps', appName)
      : context.rootPath;

    return {
      development: path.join(basePath, '.env.development'),
      staging: path.join(basePath, '.env.staging'),
      production: path.join(basePath, '.env.prod'),
      local: path.join(basePath, '.env.local')
    };
  }

  // スクリプトパス解決
  resolveScriptPath(scriptPath: string, context: ExecutionContext): string {
    if (path.isAbsolute(scriptPath)) return scriptPath;

    const appRoot = context.type === 'app-directory'
      ? context.rootPath
      : path.join(context.rootPath, 'apps', context.currentApp || 'web');

    return path.resolve(appRoot, scriptPath);
  }
}
```

### 5. 環境変数管理システム

**マルチアプリ環境変数統合**：
```typescript
// 環境変数継承システム
export class EnvironmentManager {
  // 階層的環境変数管理
  async loadEnvironmentHierarchy(
    appName: string,
    environment: string
  ): Promise<EnvironmentVariables> {
    const hierarchy = [
      // 1. ルートレベル共通設定
      path.join(this.rootPath, '.env'),
      path.join(this.rootPath, `.env.${environment}`),

      // 2. アプリレベル設定
      path.join(this.rootPath, 'apps', appName, '.env'),
      path.join(this.rootPath, 'apps', appName, `.env.${environment}`),

      // 3. ローカルオーバーライド
      path.join(this.rootPath, 'apps', appName, '.env.local')
    ];

    const merged = {};
    for (const envFile of hierarchy) {
      if (await this.fileExists(envFile)) {
        const vars = await this.parseEnvFile(envFile);
        Object.assign(merged, vars);
      }
    }

    return merged;
  }

  // 環境変数注入
  async injectVariables(
    appName: string,
    environment: string,
    command: string
  ): Promise<string> {
    const vars = await this.loadEnvironmentHierarchy(appName, environment);
    const envString = Object.entries(vars)
      .map(([key, value]) => `${key}=${value}`)
      .join(' ');

    return `${envString} ${command}`;
  }
}
```

### 6. CLI生成処理統合

**テンプレート生成時の自動設定**：
```typescript
// src/commands/create/generators/monorepo-generator.ts
export class MonorepoGenerator {
  async generateProject(options: ProjectOptions): Promise<void> {
    // 1. 基本構造生成
    await this.createDirectoryStructure(options.projectPath);

    // 2. ワークスペース設定
    await this.generateWorkspaceConfig(options);

    // 3. ルートpackage.json生成
    await this.generateRootPackageJson(options);

    // 4. 個別アプリ生成
    for (const app of options.apps) {
      await this.generateApp(app, options);
    }

    // 5. スクリプト統合
    await this.integrateScripts(options);
  }

  private async generateWorkspaceConfig(options: ProjectOptions): Promise<void> {
    const workspaceConfig = {
      packages: [
        'apps/*',
        'packages/*',
        ...(options.includeTools ? ['tools/*'] : [])
      ],
      catalog: this.generateCatalog(options.dependencies),
      ...(options.optimizations && {
        enablePerformance: [
          'node-linker=hoisted',
          'store-dir=.pnpm',
          'frozen-lockfile=true'
        ]
      })
    };

    await fs.writeFile(
      path.join(options.projectPath, 'pnpm-workspace.yaml'),
      yaml.stringify(workspaceConfig)
    );
  }

  private async integrateScripts(options: ProjectOptions): Promise<void> {
    const workspace = await this.workspaceManager.detectWorkspaces(options.projectPath);
    const scripts = this.workspaceManager.generateRootScripts(workspace);

    const rootPackageJson = await this.readPackageJson(options.projectPath);
    rootPackageJson.scripts = { ...rootPackageJson.scripts, ...scripts };

    await this.writePackageJson(options.projectPath, rootPackageJson);
  }
}
```

### 7. セキュリティとエラーハンドリング戦略

**セキュアなスクリプト実行**：
```typescript
// セキュリティ層
export class SecurityManager {
  // スクリプト実行前のバリデーション
  validateScriptExecution(
    script: string,
    context: ExecutionContext
  ): ValidationResult {
    // 1. 危険なコマンドのブロック
    const dangerousPatterns = [
      /rm\s+-rf/,          // 危険な削除コマンド
      /sudo\s+/,           // 権限昇格
      />\s*\/dev\/null/,   // 出力隠蔽
      /curl.*\|\s*sh/,     // リモートスクリプト実行
      /eval\s*\(/          // 動的評価
    ];

    for (const pattern of dangerousPatterns) {
      if (pattern.test(script)) {
        return {
          valid: false,
          reason: `Dangerous pattern detected: ${pattern.source}`,
          severity: 'critical'
        };
      }
    }

    // 2. パス範囲検証
    if (!this.validatePathScope(script, context)) {
      return {
        valid: false,
        reason: 'Script attempts to access outside project scope',
        severity: 'high'
      };
    }

    return { valid: true };
  }

  // パスエスケープ防止
  private validatePathScope(script: string, context: ExecutionContext): boolean {
    const pathPatterns = script.match(/[\.\/\\]+[\w\/\\-]+/g) || [];

    for (const pathPattern of pathPatterns) {
      const resolvedPath = path.resolve(context.rootPath, pathPattern);
      if (!resolvedPath.startsWith(context.rootPath)) {
        return false; // パスエスケープ検出
      }
    }

    return true;
  }
}
```

**包括的エラーハンドリング**：
```typescript
// エラー分類とリカバリ
export enum MonorepoErrorType {
  WORKSPACE_NOT_FOUND = 'workspace_not_found',
  SCRIPT_NOT_FOUND = 'script_not_found',
  EXECUTION_FAILED = 'execution_failed',
  DEPENDENCY_MISSING = 'dependency_missing',
  PATH_RESOLUTION_FAILED = 'path_resolution_failed',
  PERMISSION_DENIED = 'permission_denied'
}

export class MonorepoErrorHandler {
  // エラー分析と自動修復
  async handleError(
    error: MonorepoError,
    context: ExecutionContext
  ): Promise<RecoveryResult> {
    switch (error.type) {
      case MonorepoErrorType.WORKSPACE_NOT_FOUND:
        return await this.recoverWorkspace(error, context);

      case MonorepoErrorType.SCRIPT_NOT_FOUND:
        return await this.suggestAlternativeScripts(error, context);

      case MonorepoErrorType.DEPENDENCY_MISSING:
        return await this.installMissingDependencies(error, context);

      case MonorepoErrorType.PATH_RESOLUTION_FAILED:
        return await this.repairPathReferences(error, context);

      default:
        return this.provideGenericGuidance(error);
    }
  }

  // ワークスペース修復
  private async recoverWorkspace(
    error: MonorepoError,
    context: ExecutionContext
  ): Promise<RecoveryResult> {
    const workspaceFile = path.join(context.rootPath, 'pnpm-workspace.yaml');

    if (!(await this.fileExists(workspaceFile))) {
      // ワークスペースファイルを自動生成
      await this.generateDefaultWorkspace(context.rootPath);
      return {
        recovered: true,
        action: 'generated_workspace_file',
        message: 'Generated missing pnpm-workspace.yaml'
      };
    }

    // 既存ワークスペースの修復
    const apps = await this.scanForApps(context.rootPath);
    await this.updateWorkspaceConfig(workspaceFile, apps);

    return {
      recovered: true,
      action: 'updated_workspace_config',
      message: `Updated workspace config with ${apps.length} discovered apps`
    };
  }

  // スクリプト代替案提示
  private async suggestAlternativeScripts(
    error: MonorepoError,
    context: ExecutionContext
  ): Promise<RecoveryResult> {
    const availableScripts = await this.scanAvailableScripts(context);
    const suggestions = this.findSimilarScripts(error.requestedScript, availableScripts);

    return {
      recovered: false,
      action: 'suggest_alternatives',
      message: `Script '${error.requestedScript}' not found. Did you mean: ${suggestions.join(', ')}?`,
      suggestions
    };
  }
}
```

### 8. テスト戦略と自動化

**階層化テスト設計**：
```typescript
// 1. ユニットテスト - ワークスペース管理
describe('WorkspaceManager', () => {
  describe('Script Generation', () => {
    it('should generate correct filter commands', () => {
      const workspace: WorkspaceConfig = {
        apps: [
          { name: 'web', type: 'nextjs', scripts: { dev: 'next dev', build: 'next build' } },
          { name: 'mobile', type: 'expo', scripts: { start: 'expo start', build: 'expo build' } }
        ]
      };

      const scripts = workspaceManager.generateRootScripts(workspace);

      expect(scripts['web:dev']).toBe('pnpm --filter web dev');
      expect(scripts['mobile:start']).toBe('pnpm --filter mobile start');
      expect(scripts['dev']).toContain('pnpm --filter web dev');
      expect(scripts['dev']).toContain('pnpm --filter mobile start');
    });
  });

  describe('Security Validation', () => {
    it('should block dangerous commands', () => {
      const result = securityManager.validateScriptExecution(
        'rm -rf /',
        { rootPath: '/test/project', type: 'monorepo-root' }
      );

      expect(result.valid).toBe(false);
      expect(result.severity).toBe('critical');
    });

    it('should prevent path traversal', () => {
      const result = securityManager.validateScriptExecution(
        'cat ../../etc/passwd',
        { rootPath: '/test/project', type: 'monorepo-root' }
      );

      expect(result.valid).toBe(false);
      expect(result.reason).toContain('outside project scope');
    });
  });
});

// 2. 統合テスト - エンドツーエンド
describe('Monorepo Integration', () => {
  it('should handle full project generation flow', async () => {
    const projectPath = await createTempProject();
    const options: ProjectOptions = {
      projectPath,
      apps: ['web', 'mobile'],
      includeSharedPackages: true
    };

    await monorepoGenerator.generateProject(options);

    // ワークスペース設定検証
    const workspaceConfig = await readYamlFile(
      path.join(projectPath, 'pnpm-workspace.yaml')
    );
    expect(workspaceConfig.packages).toContain('apps/*');

    // スクリプト生成検証
    const rootPackageJson = await readJsonFile(
      path.join(projectPath, 'package.json')
    );
    expect(rootPackageJson.scripts['web:dev']).toBeDefined();
    expect(rootPackageJson.scripts['mobile:start']).toBeDefined();

    // 実際の実行テスト
    const result = await execCommand('pnpm web:dev --help', { cwd: projectPath });
    expect(result.exitCode).toBe(0);
  });

  it('should handle error recovery gracefully', async () => {
    const projectPath = await createCorruptedProject();

    const recoveryResult = await errorHandler.handleError(
      new MonorepoError(MonorepoErrorType.WORKSPACE_NOT_FOUND),
      { rootPath: projectPath, type: 'monorepo-root' }
    );

    expect(recoveryResult.recovered).toBe(true);
    expect(await fileExists(path.join(projectPath, 'pnpm-workspace.yaml'))).toBe(true);
  });
});

// 3. パフォーマンステスト
describe('Performance Tests', () => {
  it('should handle large monorepos efficiently', async () => {
    const largeProject = await createLargeMonorepo(50); // 50アプリ

    const startTime = Date.now();
    const workspace = await workspaceManager.detectWorkspaces(largeProject.path);
    const scripts = workspaceManager.generateRootScripts(workspace);
    const endTime = Date.now();

    expect(endTime - startTime).toBeLessThan(5000); // 5秒以内
    expect(Object.keys(scripts)).toHaveLength(expect.arrayContaining([]));
  });
});
```

### 9. パフォーマンス最適化

**キャッシュとメモ化戦略**：
```typescript
// 高速化機能
export class PerformanceOptimizer {
  private cache = new Map<string, CacheEntry>();
  private static readonly CACHE_TTL = 5 * 60 * 1000; // 5分

  // ワークスペース検出の最適化
  async getCachedWorkspace(projectPath: string): Promise<WorkspaceConfig> {
    const cacheKey = `workspace:${projectPath}`;
    const cached = this.cache.get(cacheKey);

    if (cached && Date.now() - cached.timestamp < PerformanceOptimizer.CACHE_TTL) {
      return cached.data;
    }

    const workspace = await this.workspaceManager.detectWorkspaces(projectPath);
    this.cache.set(cacheKey, {
      data: workspace,
      timestamp: Date.now()
    });

    return workspace;
  }

  // 並列スクリプト実行の最適化
  async optimizeParallelExecution(
    commands: ScriptCommand[]
  ): Promise<ExecutionPlan> {
    // 依存関係分析
    const dependencyGraph = await this.analyzeDependencies(commands);

    // 並列実行プラン生成
    const executionPlan = this.generateExecutionPlan(dependencyGraph);

    // リソース使用量最適化
    return this.optimizeResourceUsage(executionPlan);
  }

  // メモリ使用量監視
  monitorResourceUsage(): ResourceMonitor {
    return {
      memory: process.memoryUsage(),
      cpu: process.cpuUsage(),
      activeProcesses: this.countActiveProcesses(),
      suggestOptimizations: () => this.suggestOptimizations()
    };
  }
}
```

### 10. ドキュメントとガイダンス

**包括的ドキュメント戦略**：
```markdown
# モノレポ操作ガイド

## 🚀 基本操作

### 全体開発
```bash
# 全アプリ同時開発
pnpm dev

# 全アプリビルド
pnpm build:all

# 全アプリテスト
pnpm test:all
```

### 個別アプリ操作
```bash
# Webアプリ
pnpm web:dev        # 開発サーバー
pnpm web:build      # ビルド
pnpm web:db:migrate # データベースマイグレーション

# モバイルアプリ
pnpm mobile:start   # Expo開発サーバー
pnpm mobile:build   # アプリビルド

# バックエンドAPI
pnpm backend:dev    # API開発サーバー
pnpm backend:test   # APIテスト
```

## 🔧 高度な操作

### 条件付き実行
```bash
# 変更されたアプリのみテスト
pnpm test:changed

# 特定の依存関係を持つアプリのみ
pnpm --filter="[react]" build

# 並列実行制限
pnpm --filter="web|mobile" --parallel=2 build
```

## 🛠️ トラブルシューティング

### よくある問題
1. **ワークスペースが認識されない**
   - `pnpm install` を実行
   - `pnpm-workspace.yaml` の設定確認

2. **スクリプトが見つからない**
   - `pnpm run` でスクリプト一覧確認
   - アプリディレクトリの `package.json` を確認

3. **パフォーマンスが遅い**
   - `pnpm prune` で不要な依存関係削除
   - 並列実行数の調整
```

## 解決済み事項

- ✅ **将来的なアプリのディレクトリ名・スクリプト名**：
  - **ディレクトリ構造**: `apps/web` (Next.js), `apps/mobile` (Expo), `apps/backend` (API), `packages/shared` (共通ライブラリ)
  - **命名規則**: `web:*`, `mobile:*`, `backend:*`, `shared:*`
  - **既存調査**: `expo-graphql`テンプレートで実証済み（backend:dev, expo:start）

- ✅ **ルートスクリプトの命名規則統一**：
  ```typescript
  interface ScriptNamingConvention {
    // アプリケーション操作
    "[app]:dev": "開発サーバー起動";
    "[app]:build": "プロダクションビルド";
    "[app]:start": "プロダクション起動";
    "[app]:test": "テスト実行";

    // データベース操作
    "[app]:db:generate": "Prismaクライアント生成";
    "[app]:db:migrate": "マイグレーション実行";
    "[app]:db:push": "スキーマプッシュ";
    "[app]:db:studio": "Prisma Studio起動";

    // 環境変数操作
    "[app]:env:encrypt": "環境変数暗号化";
    "[app]:env:decrypt": "環境変数復号化";
    "[app]:env:apply-vercel": "Vercel環境変数適用";

    // 品質管理
    "[app]:lint": "リント実行";
    "[app]:format": "フォーマット実行";
    "[app]:typecheck": "型チェック実行";

    // 全体操作
    "dev": "全アプリ同時開発モード";
    "build:all": "全アプリビルド";
    "test:all": "全アプリテスト";
    "lint:all": "全アプリリント";
  }
  ```

- ✅ **pnpm --filterのバージョン互換性**：
  - **最小要件**: pnpm >= 7.0.0 (--filter安定化)
  - **推奨バージョン**: pnpm >= 8.0.0 (パフォーマンス向上)
  - **package.json engines設定**: `"pnpm": ">=8.0.0"`
  - **CI/CD環境**: corepack enable で統一

- ✅ **カレントディレクトリ依存問題の解決**：
  - **スクリプト内パス解決**: `process.cwd()`基準で相対パス処理
  - **環境変数ファイル**: `--cwd` オプションで作業ディレクトリ指定
  - **既存検証**: `nextjs-fullstack-admin`のスクリプトは`tsx -e`で動的import使用済み
  - **推奨パターン**:
    ```typescript
    // ルートから実行時も対応可能なパス解決
    const projectRoot = process.cwd().includes('/apps/')
      ? process.cwd()
      : path.join(process.cwd(), 'apps', 'web');
    ```

## リスク / 懸念
- スクリプト名増加により `package.json` が煩雑になる → 説明付きで一覧化し、プレフィックスを統一。
- `pnpm --filter` はパッケージ名ベースでフィルタするため、`apps/web` の `package.json` name が適切に設定されている必要がある。
- ルートからの実行時にファイルパスが崩れる場合がある → スクリプト内で `path.resolve` を活用する。

## 次のステップ
1. TODO の内容を整理し、対応方針を確定。
2. 計画レビュー → 問題なければ `[ STATUS:READY ]` へ変更。
3. 既存テンプレートの `package.json` / スクリプト整備、ドキュメント更新、動作確認を実施。

# ãƒ«ãƒ¼ãƒˆã‹ã‚‰ã® pnpm æ“ä½œä¸€å…ƒåŒ–

[ STATUS:DONE ]

## ç›®çš„
- ç”Ÿæˆã•ã‚ŒãŸãƒ¢ãƒãƒ¬ãƒï¼ˆä¾‹: `apps/web`ï¼ˆNext.jsï¼‰, å°†æ¥çš„ã«ã¯ `apps/backend`, `apps/mobile` ç­‰ï¼‰ã«å¯¾ã—ã¦ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã§ `pnpm <command>` ã‚’å®Ÿè¡Œã™ã‚Œã°å„ã‚¢ãƒ—ãƒªå›ºæœ‰ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒå®Ÿè¡Œã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚
- é–‹ç™ºè€…ãŒã‚¢ãƒ—ãƒªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¸ `cd` ã—ã¦ã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹æ‰‹é–“ã‚’ãªãã—ã€æ“ä½œæ€§ã‚’å‘ä¸Šã•ã›ã‚‹ã€‚

## ã‚´ãƒ¼ãƒ«
1. ãƒ«ãƒ¼ãƒˆ `package.json` ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆçµŒç”±ã§ã€`apps/web`ï¼ˆNext.jsï¼‰ã® `env:*`, `db:*`, `dev`, `build`, `lint` ç­‰ãŒå‘¼ã³å‡ºã›ã‚‹ã€‚
2. å°†æ¥çš„ã« `apps/expo` ãªã©ãŒè¿½åŠ ã•ã‚Œã¦ã‚‚åŒã˜æ–¹é‡ã§æ“ä½œå¯èƒ½ã«ã™ã‚‹ãŸã‚ã€å†åˆ©ç”¨ã—ã‚„ã™ã„ä»•çµ„ã¿ã‚’æ•´ãˆã¦ãŠãã€‚
3. README ã‚„ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã€ãƒ«ãƒ¼ãƒˆæ“ä½œã®æ–¹æ³•ãŒæ˜è¨˜ã•ã‚Œã¦ã„ã‚‹ã€‚

## ã‚¹ã‚³ãƒ¼ãƒ—
- ãƒ«ãƒ¼ãƒˆ `package.json` ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆè¿½åŠ /æ›´æ–°ï¼ˆ`pnpm --filter` ã®æ´»ç”¨ï¼‰ã€‚
- `pnpm-workspace.yaml` ã®è¨­å®šç¢ºèªï¼ˆ`apps/*` ãŒãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã«å«ã¾ã‚Œã¦ã„ã‚‹ã“ã¨ï¼‰ã€‚
- `templates/nextjs-fullstack-admin` ç­‰ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«å†…åŒ…ã•ã‚ŒãŸ `package.json` ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®æ•´å‚™ã€‚
- CLI ç”Ÿæˆå‡¦ç†ã§ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆè¿½åŠ ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰ã€‚

## ã‚¢ã‚¦ãƒˆã‚ªãƒ–ã‚¹ã‚³ãƒ¼ãƒ—
- ä»–ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ï¼ˆnpm/yarnï¼‰ã§ã®å¯¾å¿œã€‚
- æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ç’°å¢ƒã¸ã®è‡ªå‹•ç§»è¡Œã€‚

## æŠ€è¡“è©³ç´°è¨­è¨ˆ

### 1. ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

```typescript
// ãƒ¢ãƒãƒ¬ãƒæ§‹é€ å®šç¾©
interface MonorepoArchitecture {
  // ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹æ§‹é€ 
  structure: {
    apps: {
      web: 'Next.js ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚¢ãƒ—ãƒª';
      mobile: 'Expo React Nativeã‚¢ãƒ—ãƒª';
      backend: 'Express/Fastify APIã‚µãƒ¼ãƒãƒ¼';
    };
    packages: {
      shared: 'å…±é€šãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£';
      ui: 'å…±é€šUIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ';
      config: 'å…±é€šè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«';
    };
  };

  // ã‚¹ã‚¯ãƒªãƒ—ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
  scriptManagement: {
    root: 'ãƒ«ãƒ¼ãƒˆpackage.jsonã§å…¨ä½“åˆ¶å¾¡';
    delegation: 'pnpm --filterã§å€‹åˆ¥ã‚¢ãƒ—ãƒªã¸å§”è­²';
    aggregation: 'ä¸¦åˆ—å®Ÿè¡Œã¨ãƒ­ã‚°é›†ç´„';
  };
}
```

### 2. ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

**pnpm-workspace.yaml æœ€é©åŒ–è¨­è¨ˆ**ï¼š
```yaml
# éšå±¤çš„ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹å®šç¾©
packages:
  # ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤
  - 'apps/*'
  # å…±é€šãƒ©ã‚¤ãƒ–ãƒ©ãƒªå±¤
  - 'packages/*'
  # ãƒ„ãƒ¼ãƒ«å±¤
  - 'tools/*'

# ä¾å­˜é–¢ä¿‚æœ€é©åŒ–
catalog:
  # å…±é€šä¾å­˜é–¢ä¿‚ã®çµ±ä¸€ç®¡ç†
  react: '^19.2.0'
  typescript: '^5.9.3'
  '@biomejs/biome': '^2.2.5'

# ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
enablePerformance:
  - 'node-linker=hoisted'  # ãƒ›ã‚¤ã‚¹ãƒˆæœ€é©åŒ–
  - 'store-dir=.pnpm'      # ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆã‚¢
  - 'frozen-lockfile=true' # CI/CDæœ€é©åŒ–
```

**å‹•çš„ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ **ï¼š
```typescript
// src/utils/workspace-manager/
export class WorkspaceManager {
  // ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹è‡ªå‹•æ¤œå‡º
  async detectWorkspaces(projectPath: string): Promise<WorkspaceConfig> {
    const apps = await this.scanDirectory(path.join(projectPath, 'apps'));
    const packages = await this.scanDirectory(path.join(projectPath, 'packages'));

    return {
      apps: apps.map(app => ({
        name: app.name,
        type: this.detectAppType(app.path),
        scripts: this.extractScripts(app.packageJson)
      })),
      packages: packages.map(pkg => ({
        name: pkg.name,
        type: 'library',
        exports: this.extractExports(pkg.packageJson)
      }))
    };
  }

  // ã‚¹ã‚¯ãƒªãƒ—ãƒˆè‡ªå‹•ç”Ÿæˆ
  generateRootScripts(workspace: WorkspaceConfig): ScriptMap {
    const scripts: ScriptMap = {};

    // ã‚¢ãƒ—ãƒªåˆ¥ã‚¹ã‚¯ãƒªãƒ—ãƒˆç”Ÿæˆ
    for (const app of workspace.apps) {
      for (const [scriptName, scriptCommand] of Object.entries(app.scripts)) {
        scripts[`${app.name}:${scriptName}`] = `pnpm --filter ${app.name} ${scriptName}`;
      }
    }

    // é›†ç´„ã‚¹ã‚¯ãƒªãƒ—ãƒˆç”Ÿæˆ
    scripts['dev'] = workspace.apps
      .map(app => `pnpm --filter ${app.name} dev`)
      .join(' & ');

    return scripts;
  }
}
```

### 3. ã‚¹ã‚¯ãƒªãƒ—ãƒˆå§”è­²ã‚·ã‚¹ãƒ†ãƒ 

**é«˜åº¦ãªãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°æˆ¦ç•¥**ï¼š
```typescript
// ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³
export class ScriptExecutor {
  // æ¡ä»¶ä»˜ãå®Ÿè¡Œ
  async executeConditional(
    command: string,
    filters: ExecutionFilter[]
  ): Promise<ExecutionResult> {
    const targets = await this.resolveTargets(filters);

    return Promise.allSettled(
      targets.map(target => this.executeSingle(target, command))
    );
  }

  // ä¸¦åˆ—å®Ÿè¡Œã¨ãƒ­ã‚°ç®¡ç†
  async executeParallel(
    commands: Array<{ app: string; command: string }>
  ): Promise<AggregatedResult> {
    const executions = commands.map(({ app, command }) =>
      this.executeWithLogging(app, command)
    );

    const results = await Promise.allSettled(executions);
    return this.aggregateResults(results);
  }

  // ãƒ­ã‚°ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°
  private executeWithLogging(
    app: string,
    command: string
  ): Promise<ExecutionResult> {
    const process = spawn('pnpm', ['--filter', app, ...command.split(' ')]);

    process.stdout.on('data', (data) => {
      console.log(`[${app}] ${data.toString()}`);
    });

    process.stderr.on('data', (data) => {
      console.error(`[${app}] ${data.toString()}`);
    });

    return new Promise((resolve, reject) => {
      process.on('close', (code) => {
        resolve({ app, command, exitCode: code, success: code === 0 });
      });
    });
  }
}
```

### 4. ãƒ‘ã‚¹è§£æ±ºã‚·ã‚¹ãƒ†ãƒ 

**ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å¯¾å¿œ**ï¼š
```typescript
// src/utils/path-resolver/
export class PathResolver {
  // å®Ÿè¡Œã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæ¤œå‡º
  detectExecutionContext(): ExecutionContext {
    const cwd = process.cwd();
    const packageJson = this.findNearestPackageJson(cwd);

    if (packageJson.workspaces) {
      return {
        type: 'monorepo-root',
        rootPath: cwd,
        currentApp: null
      };
    }

    if (cwd.includes('/apps/')) {
      return {
        type: 'app-directory',
        rootPath: this.findMonorepoRoot(cwd),
        currentApp: this.extractAppName(cwd)
      };
    }

    return {
      type: 'standalone',
      rootPath: cwd,
      currentApp: null
    };
  }

  // ç’°å¢ƒå¤‰æ•°ãƒ•ã‚¡ã‚¤ãƒ«è§£æ±º
  resolveEnvFiles(context: ExecutionContext, appName: string): EnvFilePaths {
    const basePath = context.type === 'monorepo-root'
      ? path.join(context.rootPath, 'apps', appName)
      : context.rootPath;

    return {
      development: path.join(basePath, '.env.development'),
      staging: path.join(basePath, '.env.staging'),
      production: path.join(basePath, '.env.prod'),
      local: path.join(basePath, '.env.local')
    };
  }

  // ã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒ‘ã‚¹è§£æ±º
  resolveScriptPath(scriptPath: string, context: ExecutionContext): string {
    if (path.isAbsolute(scriptPath)) return scriptPath;

    const appRoot = context.type === 'app-directory'
      ? context.rootPath
      : path.join(context.rootPath, 'apps', context.currentApp || 'web');

    return path.resolve(appRoot, scriptPath);
  }
}
```

### 5. ç’°å¢ƒå¤‰æ•°ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

**ãƒãƒ«ãƒã‚¢ãƒ—ãƒªç’°å¢ƒå¤‰æ•°çµ±åˆ**ï¼š
```typescript
// ç’°å¢ƒå¤‰æ•°ç¶™æ‰¿ã‚·ã‚¹ãƒ†ãƒ 
export class EnvironmentManager {
  // éšå±¤çš„ç’°å¢ƒå¤‰æ•°ç®¡ç†
  async loadEnvironmentHierarchy(
    appName: string,
    environment: string
  ): Promise<EnvironmentVariables> {
    const hierarchy = [
      // 1. ãƒ«ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«å…±é€šè¨­å®š
      path.join(this.rootPath, '.env'),
      path.join(this.rootPath, `.env.${environment}`),

      // 2. ã‚¢ãƒ—ãƒªãƒ¬ãƒ™ãƒ«è¨­å®š
      path.join(this.rootPath, 'apps', appName, '.env'),
      path.join(this.rootPath, 'apps', appName, `.env.${environment}`),

      // 3. ãƒ­ãƒ¼ã‚«ãƒ«ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
      path.join(this.rootPath, 'apps', appName, '.env.local')
    ];

    const merged = {};
    for (const envFile of hierarchy) {
      if (await this.fileExists(envFile)) {
        const vars = await this.parseEnvFile(envFile);
        Object.assign(merged, vars);
      }
    }

    return merged;
  }

  // ç’°å¢ƒå¤‰æ•°æ³¨å…¥
  async injectVariables(
    appName: string,
    environment: string,
    command: string
  ): Promise<string> {
    const vars = await this.loadEnvironmentHierarchy(appName, environment);
    const envString = Object.entries(vars)
      .map(([key, value]) => `${key}=${value}`)
      .join(' ');

    return `${envString} ${command}`;
  }
}
```

### 6. CLIç”Ÿæˆå‡¦ç†çµ±åˆ

**ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆæ™‚ã®è‡ªå‹•è¨­å®š**ï¼š
```typescript
// src/commands/create/generators/monorepo-generator.ts
export class MonorepoGenerator {
  async generateProject(options: ProjectOptions): Promise<void> {
    // 1. åŸºæœ¬æ§‹é€ ç”Ÿæˆ
    await this.createDirectoryStructure(options.projectPath);

    // 2. ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹è¨­å®š
    await this.generateWorkspaceConfig(options);

    // 3. ãƒ«ãƒ¼ãƒˆpackage.jsonç”Ÿæˆ
    await this.generateRootPackageJson(options);

    // 4. å€‹åˆ¥ã‚¢ãƒ—ãƒªç”Ÿæˆ
    for (const app of options.apps) {
      await this.generateApp(app, options);
    }

    // 5. ã‚¹ã‚¯ãƒªãƒ—ãƒˆçµ±åˆ
    await this.integrateScripts(options);
  }

  private async generateWorkspaceConfig(options: ProjectOptions): Promise<void> {
    const workspaceConfig = {
      packages: [
        'apps/*',
        'packages/*',
        ...(options.includeTools ? ['tools/*'] : [])
      ],
      catalog: this.generateCatalog(options.dependencies),
      ...(options.optimizations && {
        enablePerformance: [
          'node-linker=hoisted',
          'store-dir=.pnpm',
          'frozen-lockfile=true'
        ]
      })
    };

    await fs.writeFile(
      path.join(options.projectPath, 'pnpm-workspace.yaml'),
      yaml.stringify(workspaceConfig)
    );
  }

  private async integrateScripts(options: ProjectOptions): Promise<void> {
    const workspace = await this.workspaceManager.detectWorkspaces(options.projectPath);
    const scripts = this.workspaceManager.generateRootScripts(workspace);

    const rootPackageJson = await this.readPackageJson(options.projectPath);
    rootPackageJson.scripts = { ...rootPackageJson.scripts, ...scripts };

    await this.writePackageJson(options.projectPath, rootPackageJson);
  }
}
```

### 7. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æˆ¦ç•¥

**ã‚»ã‚­ãƒ¥ã‚¢ãªã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ**ï¼š
```typescript
// ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å±¤
export class SecurityManager {
  // ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œå‰ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  validateScriptExecution(
    script: string,
    context: ExecutionContext
  ): ValidationResult {
    // 1. å±é™ºãªã‚³ãƒãƒ³ãƒ‰ã®ãƒ–ãƒ­ãƒƒã‚¯
    const dangerousPatterns = [
      /rm\s+-rf/,          // å±é™ºãªå‰Šé™¤ã‚³ãƒãƒ³ãƒ‰
      /sudo\s+/,           // æ¨©é™æ˜‡æ ¼
      />\s*\/dev\/null/,   // å‡ºåŠ›éš è”½
      /curl.*\|\s*sh/,     // ãƒªãƒ¢ãƒ¼ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
      /eval\s*\(/          // å‹•çš„è©•ä¾¡
    ];

    for (const pattern of dangerousPatterns) {
      if (pattern.test(script)) {
        return {
          valid: false,
          reason: `Dangerous pattern detected: ${pattern.source}`,
          severity: 'critical'
        };
      }
    }

    // 2. ãƒ‘ã‚¹ç¯„å›²æ¤œè¨¼
    if (!this.validatePathScope(script, context)) {
      return {
        valid: false,
        reason: 'Script attempts to access outside project scope',
        severity: 'high'
      };
    }

    return { valid: true };
  }

  // ãƒ‘ã‚¹ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é˜²æ­¢
  private validatePathScope(script: string, context: ExecutionContext): boolean {
    const pathPatterns = script.match(/[\.\/\\]+[\w\/\\-]+/g) || [];

    for (const pathPattern of pathPatterns) {
      const resolvedPath = path.resolve(context.rootPath, pathPattern);
      if (!resolvedPath.startsWith(context.rootPath)) {
        return false; // ãƒ‘ã‚¹ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—æ¤œå‡º
      }
    }

    return true;
  }
}
```

**åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**ï¼š
```typescript
// ã‚¨ãƒ©ãƒ¼åˆ†é¡ã¨ãƒªã‚«ãƒãƒª
export enum MonorepoErrorType {
  WORKSPACE_NOT_FOUND = 'workspace_not_found',
  SCRIPT_NOT_FOUND = 'script_not_found',
  EXECUTION_FAILED = 'execution_failed',
  DEPENDENCY_MISSING = 'dependency_missing',
  PATH_RESOLUTION_FAILED = 'path_resolution_failed',
  PERMISSION_DENIED = 'permission_denied'
}

export class MonorepoErrorHandler {
  // ã‚¨ãƒ©ãƒ¼åˆ†æã¨è‡ªå‹•ä¿®å¾©
  async handleError(
    error: MonorepoError,
    context: ExecutionContext
  ): Promise<RecoveryResult> {
    switch (error.type) {
      case MonorepoErrorType.WORKSPACE_NOT_FOUND:
        return await this.recoverWorkspace(error, context);

      case MonorepoErrorType.SCRIPT_NOT_FOUND:
        return await this.suggestAlternativeScripts(error, context);

      case MonorepoErrorType.DEPENDENCY_MISSING:
        return await this.installMissingDependencies(error, context);

      case MonorepoErrorType.PATH_RESOLUTION_FAILED:
        return await this.repairPathReferences(error, context);

      default:
        return this.provideGenericGuidance(error);
    }
  }

  // ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ä¿®å¾©
  private async recoverWorkspace(
    error: MonorepoError,
    context: ExecutionContext
  ): Promise<RecoveryResult> {
    const workspaceFile = path.join(context.rootPath, 'pnpm-workspace.yaml');

    if (!(await this.fileExists(workspaceFile))) {
      // ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è‡ªå‹•ç”Ÿæˆ
      await this.generateDefaultWorkspace(context.rootPath);
      return {
        recovered: true,
        action: 'generated_workspace_file',
        message: 'Generated missing pnpm-workspace.yaml'
      };
    }

    // æ—¢å­˜ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã®ä¿®å¾©
    const apps = await this.scanForApps(context.rootPath);
    await this.updateWorkspaceConfig(workspaceFile, apps);

    return {
      recovered: true,
      action: 'updated_workspace_config',
      message: `Updated workspace config with ${apps.length} discovered apps`
    };
  }

  // ã‚¹ã‚¯ãƒªãƒ—ãƒˆä»£æ›¿æ¡ˆæç¤º
  private async suggestAlternativeScripts(
    error: MonorepoError,
    context: ExecutionContext
  ): Promise<RecoveryResult> {
    const availableScripts = await this.scanAvailableScripts(context);
    const suggestions = this.findSimilarScripts(error.requestedScript, availableScripts);

    return {
      recovered: false,
      action: 'suggest_alternatives',
      message: `Script '${error.requestedScript}' not found. Did you mean: ${suggestions.join(', ')}?`,
      suggestions
    };
  }
}
```

### 8. ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã¨è‡ªå‹•åŒ–

**éšå±¤åŒ–ãƒ†ã‚¹ãƒˆè¨­è¨ˆ**ï¼š
```typescript
// 1. ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ - ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ç®¡ç†
describe('WorkspaceManager', () => {
  describe('Script Generation', () => {
    it('should generate correct filter commands', () => {
      const workspace: WorkspaceConfig = {
        apps: [
          { name: 'web', type: 'nextjs', scripts: { dev: 'next dev', build: 'next build' } },
          { name: 'mobile', type: 'expo', scripts: { start: 'expo start', build: 'expo build' } }
        ]
      };

      const scripts = workspaceManager.generateRootScripts(workspace);

      expect(scripts['web:dev']).toBe('pnpm --filter web dev');
      expect(scripts['mobile:start']).toBe('pnpm --filter mobile start');
      expect(scripts['dev']).toContain('pnpm --filter web dev');
      expect(scripts['dev']).toContain('pnpm --filter mobile start');
    });
  });

  describe('Security Validation', () => {
    it('should block dangerous commands', () => {
      const result = securityManager.validateScriptExecution(
        'rm -rf /',
        { rootPath: '/test/project', type: 'monorepo-root' }
      );

      expect(result.valid).toBe(false);
      expect(result.severity).toBe('critical');
    });

    it('should prevent path traversal', () => {
      const result = securityManager.validateScriptExecution(
        'cat ../../etc/passwd',
        { rootPath: '/test/project', type: 'monorepo-root' }
      );

      expect(result.valid).toBe(false);
      expect(result.reason).toContain('outside project scope');
    });
  });
});

// 2. çµ±åˆãƒ†ã‚¹ãƒˆ - ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰
describe('Monorepo Integration', () => {
  it('should handle full project generation flow', async () => {
    const projectPath = await createTempProject();
    const options: ProjectOptions = {
      projectPath,
      apps: ['web', 'mobile'],
      includeSharedPackages: true
    };

    await monorepoGenerator.generateProject(options);

    // ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹è¨­å®šæ¤œè¨¼
    const workspaceConfig = await readYamlFile(
      path.join(projectPath, 'pnpm-workspace.yaml')
    );
    expect(workspaceConfig.packages).toContain('apps/*');

    // ã‚¹ã‚¯ãƒªãƒ—ãƒˆç”Ÿæˆæ¤œè¨¼
    const rootPackageJson = await readJsonFile(
      path.join(projectPath, 'package.json')
    );
    expect(rootPackageJson.scripts['web:dev']).toBeDefined();
    expect(rootPackageJson.scripts['mobile:start']).toBeDefined();

    // å®Ÿéš›ã®å®Ÿè¡Œãƒ†ã‚¹ãƒˆ
    const result = await execCommand('pnpm web:dev --help', { cwd: projectPath });
    expect(result.exitCode).toBe(0);
  });

  it('should handle error recovery gracefully', async () => {
    const projectPath = await createCorruptedProject();

    const recoveryResult = await errorHandler.handleError(
      new MonorepoError(MonorepoErrorType.WORKSPACE_NOT_FOUND),
      { rootPath: projectPath, type: 'monorepo-root' }
    );

    expect(recoveryResult.recovered).toBe(true);
    expect(await fileExists(path.join(projectPath, 'pnpm-workspace.yaml'))).toBe(true);
  });
});

// 3. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
describe('Performance Tests', () => {
  it('should handle large monorepos efficiently', async () => {
    const largeProject = await createLargeMonorepo(50); // 50ã‚¢ãƒ—ãƒª

    const startTime = Date.now();
    const workspace = await workspaceManager.detectWorkspaces(largeProject.path);
    const scripts = workspaceManager.generateRootScripts(workspace);
    const endTime = Date.now();

    expect(endTime - startTime).toBeLessThan(5000); // 5ç§’ä»¥å†…
    expect(Object.keys(scripts)).toHaveLength(expect.arrayContaining([]));
  });
});
```

### 9. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

**ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¨ãƒ¡ãƒ¢åŒ–æˆ¦ç•¥**ï¼š
```typescript
// é«˜é€ŸåŒ–æ©Ÿèƒ½
export class PerformanceOptimizer {
  private cache = new Map<string, CacheEntry>();
  private static readonly CACHE_TTL = 5 * 60 * 1000; // 5åˆ†

  // ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹æ¤œå‡ºã®æœ€é©åŒ–
  async getCachedWorkspace(projectPath: string): Promise<WorkspaceConfig> {
    const cacheKey = `workspace:${projectPath}`;
    const cached = this.cache.get(cacheKey);

    if (cached && Date.now() - cached.timestamp < PerformanceOptimizer.CACHE_TTL) {
      return cached.data;
    }

    const workspace = await this.workspaceManager.detectWorkspaces(projectPath);
    this.cache.set(cacheKey, {
      data: workspace,
      timestamp: Date.now()
    });

    return workspace;
  }

  // ä¸¦åˆ—ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œã®æœ€é©åŒ–
  async optimizeParallelExecution(
    commands: ScriptCommand[]
  ): Promise<ExecutionPlan> {
    // ä¾å­˜é–¢ä¿‚åˆ†æ
    const dependencyGraph = await this.analyzeDependencies(commands);

    // ä¸¦åˆ—å®Ÿè¡Œãƒ—ãƒ©ãƒ³ç”Ÿæˆ
    const executionPlan = this.generateExecutionPlan(dependencyGraph);

    // ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨é‡æœ€é©åŒ–
    return this.optimizeResourceUsage(executionPlan);
  }

  // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç›£è¦–
  monitorResourceUsage(): ResourceMonitor {
    return {
      memory: process.memoryUsage(),
      cpu: process.cpuUsage(),
      activeProcesses: this.countActiveProcesses(),
      suggestOptimizations: () => this.suggestOptimizations()
    };
  }
}
```

### 10. ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹

**åŒ…æ‹¬çš„ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæˆ¦ç•¥**ï¼š
```markdown
# ãƒ¢ãƒãƒ¬ãƒæ“ä½œã‚¬ã‚¤ãƒ‰

## ğŸš€ åŸºæœ¬æ“ä½œ

### å…¨ä½“é–‹ç™º
```bash
# å…¨ã‚¢ãƒ—ãƒªåŒæ™‚é–‹ç™º
pnpm dev

# å…¨ã‚¢ãƒ—ãƒªãƒ“ãƒ«ãƒ‰
pnpm build:all

# å…¨ã‚¢ãƒ—ãƒªãƒ†ã‚¹ãƒˆ
pnpm test:all
```

### å€‹åˆ¥ã‚¢ãƒ—ãƒªæ“ä½œ
```bash
# Webã‚¢ãƒ—ãƒª
pnpm web:dev        # é–‹ç™ºã‚µãƒ¼ãƒãƒ¼
pnpm web:build      # ãƒ“ãƒ«ãƒ‰
pnpm web:db:migrate # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

# ãƒ¢ãƒã‚¤ãƒ«ã‚¢ãƒ—ãƒª
pnpm mobile:start   # Expoé–‹ç™ºã‚µãƒ¼ãƒãƒ¼
pnpm mobile:build   # ã‚¢ãƒ—ãƒªãƒ“ãƒ«ãƒ‰

# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰API
pnpm backend:dev    # APIé–‹ç™ºã‚µãƒ¼ãƒãƒ¼
pnpm backend:test   # APIãƒ†ã‚¹ãƒˆ
```

## ğŸ”§ é«˜åº¦ãªæ“ä½œ

### æ¡ä»¶ä»˜ãå®Ÿè¡Œ
```bash
# å¤‰æ›´ã•ã‚ŒãŸã‚¢ãƒ—ãƒªã®ã¿ãƒ†ã‚¹ãƒˆ
pnpm test:changed

# ç‰¹å®šã®ä¾å­˜é–¢ä¿‚ã‚’æŒã¤ã‚¢ãƒ—ãƒªã®ã¿
pnpm --filter="[react]" build

# ä¸¦åˆ—å®Ÿè¡Œåˆ¶é™
pnpm --filter="web|mobile" --parallel=2 build
```

## ğŸ› ï¸ ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ã‚ˆãã‚ã‚‹å•é¡Œ
1. **ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãŒèªè­˜ã•ã‚Œãªã„**
   - `pnpm install` ã‚’å®Ÿè¡Œ
   - `pnpm-workspace.yaml` ã®è¨­å®šç¢ºèª

2. **ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã„**
   - `pnpm run` ã§ã‚¹ã‚¯ãƒªãƒ—ãƒˆä¸€è¦§ç¢ºèª
   - ã‚¢ãƒ—ãƒªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã® `package.json` ã‚’ç¢ºèª

3. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒé…ã„**
   - `pnpm prune` ã§ä¸è¦ãªä¾å­˜é–¢ä¿‚å‰Šé™¤
   - ä¸¦åˆ—å®Ÿè¡Œæ•°ã®èª¿æ•´
```

## è§£æ±ºæ¸ˆã¿äº‹é …

- âœ… **å°†æ¥çš„ãªã‚¢ãƒ—ãƒªã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåãƒ»ã‚¹ã‚¯ãƒªãƒ—ãƒˆå**ï¼š
  - **ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ **: `apps/web` (Next.js), `apps/mobile` (Expo), `apps/backend` (API), `packages/shared` (å…±é€šãƒ©ã‚¤ãƒ–ãƒ©ãƒª)
  - **å‘½åè¦å‰‡**: `web:*`, `mobile:*`, `backend:*`, `shared:*`
  - **æ—¢å­˜èª¿æŸ»**: `expo-graphql`ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§å®Ÿè¨¼æ¸ˆã¿ï¼ˆbackend:dev, expo:startï¼‰

- âœ… **ãƒ«ãƒ¼ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å‘½åè¦å‰‡çµ±ä¸€**ï¼š
  ```typescript
  interface ScriptNamingConvention {
    // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³æ“ä½œ
    "[app]:dev": "é–‹ç™ºã‚µãƒ¼ãƒãƒ¼èµ·å‹•";
    "[app]:build": "ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ãƒ“ãƒ«ãƒ‰";
    "[app]:start": "ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³èµ·å‹•";
    "[app]:test": "ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ";

    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œ
    "[app]:db:generate": "Prismaã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”Ÿæˆ";
    "[app]:db:migrate": "ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ";
    "[app]:db:push": "ã‚¹ã‚­ãƒ¼ãƒãƒ—ãƒƒã‚·ãƒ¥";
    "[app]:db:studio": "Prisma Studioèµ·å‹•";

    // ç’°å¢ƒå¤‰æ•°æ“ä½œ
    "[app]:env:encrypt": "ç’°å¢ƒå¤‰æ•°æš—å·åŒ–";
    "[app]:env:decrypt": "ç’°å¢ƒå¤‰æ•°å¾©å·åŒ–";
    "[app]:env:apply-vercel": "Vercelç’°å¢ƒå¤‰æ•°é©ç”¨";

    // å“è³ªç®¡ç†
    "[app]:lint": "ãƒªãƒ³ãƒˆå®Ÿè¡Œ";
    "[app]:format": "ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå®Ÿè¡Œ";
    "[app]:typecheck": "å‹ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ";

    // å…¨ä½“æ“ä½œ
    "dev": "å…¨ã‚¢ãƒ—ãƒªåŒæ™‚é–‹ç™ºãƒ¢ãƒ¼ãƒ‰";
    "build:all": "å…¨ã‚¢ãƒ—ãƒªãƒ“ãƒ«ãƒ‰";
    "test:all": "å…¨ã‚¢ãƒ—ãƒªãƒ†ã‚¹ãƒˆ";
    "lint:all": "å…¨ã‚¢ãƒ—ãƒªãƒªãƒ³ãƒˆ";
  }
  ```

- âœ… **pnpm --filterã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³äº’æ›æ€§**ï¼š
  - **æœ€å°è¦ä»¶**: pnpm >= 7.0.0 (--filterå®‰å®šåŒ–)
  - **æ¨å¥¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: pnpm >= 8.0.0 (ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Š)
  - **package.json enginesè¨­å®š**: `"pnpm": ">=8.0.0"`
  - **CI/CDç’°å¢ƒ**: corepack enable ã§çµ±ä¸€

- âœ… **ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä¾å­˜å•é¡Œã®è§£æ±º**ï¼š
  - **ã‚¹ã‚¯ãƒªãƒ—ãƒˆå†…ãƒ‘ã‚¹è§£æ±º**: `process.cwd()`åŸºæº–ã§ç›¸å¯¾ãƒ‘ã‚¹å‡¦ç†
  - **ç’°å¢ƒå¤‰æ•°ãƒ•ã‚¡ã‚¤ãƒ«**: `--cwd` ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæŒ‡å®š
  - **æ—¢å­˜æ¤œè¨¼**: `nextjs-fullstack-admin`ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯`tsx -e`ã§å‹•çš„importä½¿ç”¨æ¸ˆã¿
  - **æ¨å¥¨ãƒ‘ã‚¿ãƒ¼ãƒ³**:
    ```typescript
    // ãƒ«ãƒ¼ãƒˆã‹ã‚‰å®Ÿè¡Œæ™‚ã‚‚å¯¾å¿œå¯èƒ½ãªãƒ‘ã‚¹è§£æ±º
    const projectRoot = process.cwd().includes('/apps/')
      ? process.cwd()
      : path.join(process.cwd(), 'apps', 'web');
    ```

## ãƒªã‚¹ã‚¯ / æ‡¸å¿µ
- ã‚¹ã‚¯ãƒªãƒ—ãƒˆåå¢—åŠ ã«ã‚ˆã‚Š `package.json` ãŒç…©é›‘ã«ãªã‚‹ â†’ èª¬æ˜ä»˜ãã§ä¸€è¦§åŒ–ã—ã€ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’çµ±ä¸€ã€‚
- `pnpm --filter` ã¯ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åãƒ™ãƒ¼ã‚¹ã§ãƒ•ã‚£ãƒ«ã‚¿ã™ã‚‹ãŸã‚ã€`apps/web` ã® `package.json` name ãŒé©åˆ‡ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
- ãƒ«ãƒ¼ãƒˆã‹ã‚‰ã®å®Ÿè¡Œæ™‚ã«ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒå´©ã‚Œã‚‹å ´åˆãŒã‚ã‚‹ â†’ ã‚¹ã‚¯ãƒªãƒ—ãƒˆå†…ã§ `path.resolve` ã‚’æ´»ç”¨ã™ã‚‹ã€‚

## æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—
1. TODO ã®å†…å®¹ã‚’æ•´ç†ã—ã€å¯¾å¿œæ–¹é‡ã‚’ç¢ºå®šã€‚
2. è¨ˆç”»ãƒ¬ãƒ“ãƒ¥ãƒ¼ â†’ å•é¡Œãªã‘ã‚Œã° `[ STATUS:READY ]` ã¸å¤‰æ›´ã€‚
3. æ—¢å­˜ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã® `package.json` / ã‚¹ã‚¯ãƒªãƒ—ãƒˆæ•´å‚™ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ã€å‹•ä½œç¢ºèªã‚’å®Ÿæ–½ã€‚

# Fluorite-flake ユーティリティ機能

## 1. ユーティリティシステム概要

Fluorite-flakeのユーティリティシステムは、共通機能を提供する再利用可能なモジュール群です。国際化、ファイル操作、テンプレート処理、ロギングなど、アプリケーション全体で使用される基盤機能を統一的に管理しています。

### 1.1 ユーティリティアーキテクチャ概観

```
┌─────────────────────────────────────────────────────────────────┐
│                   ユーティリティアーキテクチャ                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────┐    ┌─────────────────┐    ┌──────────────┐ │
│  │ 国際化・UI      │    │ ファイル操作    │    │ 開発支援     │ │
│  │                 │    │                 │    │              │ │
│  │ ├ i18n.ts       │    │ ├ file-generation│    │ ├ logger.ts  │ │
│  │ ├ cli-utils.ts  │    │ ├ template-reader│    │ ├ spinner-   │ │
│  │ ├ spinner-      │    │ ├ project-       │    │ │   manager  │ │
│  │ │   manager.ts  │    │ │   structure    │    │ └ error-     │ │
│  │ └ error-types.ts│    │ └ package-json   │    │   types.ts   │ │
│  └─────────────────┘    └─────────────────┘    └──────────────┘ │
│                                                                 │
│  ┌─────────────────┐    ┌─────────────────┐    ┌──────────────┐ │
│  │ 文字列処理      │    │ 環境・設定      │    │ 外部統合     │ │
│  │                 │    │                 │    │              │ │
│  │ ├ slugify.ts    │    │ ├ env-file.ts   │    │ ├ download.ts │ │
│  │ └ auth-types.ts │    │ └ wrangler-     │    │ └ cloud/      │ │
│  │                 │    │   dashboard.ts  │    │   ├ cli-     │ │
│  │                 │    │                 │    │   │  provisioner│
│  │                 │    │                 │    │   ├ real-    │ │
│  │                 │    │                 │    │   │  provisioner│
│  │                 │    │                 │    │   └ mock-    │ │
│  │                 │    │                 │    │     provisioner│
│  └─────────────────┘    └─────────────────┘    └──────────────┘ │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                         設計原則                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ├ 単一責任原則: 各モジュールは明確な責任範囲を持つ              │
│  ├ 依存関係最小化: 外部依存を最小限に抑制                       │
│  ├ 型安全性: TypeScript型システムを活用した安全な実装            │
│  ├ テスタビリティ: ユニットテスト可能な設計                     │
│  ├ 再利用性: 他のモジュールから容易に利用可能                   │
│  └ 拡張性: 新機能追加時の影響範囲を最小化                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 2. 国際化（i18n）システム

### 2.1 国際化アーキテクチャ

```
┌─────────────────────────────────────────────────────────┐
│                   国際化システム                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  対応言語:                                              │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ const SUPPORTED_LOCALES = ['en', 'ja'] as const;    │ │
│  │                                                     │ │
│  │ ├ en (English)  - デフォルト言語                    │ │
│  │ └ ja (Japanese) - 日本語対応                        │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
│  メッセージ管理システム:                                │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ type MessageValue = string |                        │ │
│  │   ((params: MessageParams) => string);              │ │
│  │                                                     │ │
│  │ type MessageDictionary =                            │ │
│  │   Record<string, MessageValue>;                     │ │
│  │                                                     │ │
│  │ // タイプセーフなメッセージキー                      │ │
│  │ type MessageKey =                                   │ │
│  │   | 'cli.description'                               │ │
│  │   | 'create.invalidFramework'                       │ │
│  │   | 'create.missingRequiredArgs'                    │ │
│  │   | ...;                                            │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
│  メッセージ定義例:                                      │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ const messageMap: Record<SupportedLocale,           │ │
│  │                         MessageDictionary> = {     │ │
│  │   en: {                                             │ │
│  │     'cli.description':                              │ │
│  │       'Multi-framework project generator',          │ │
│  │     'create.invalidFramework': ({ value }) =>       │ │
│  │       `Invalid framework: ${value}`,                │ │
│  │     'create.missingRequiredArgs':                   │ │
│  │       'CLI arguments missing required fields'       │ │
│  │   },                                                │ │
│  │   ja: {                                             │ │
│  │     'cli.description':                              │ │
│  │       'マルチフレームワーク対応プロジェクトジェネレータ',│ │
│  │     'create.invalidFramework': ({ value }) =>       │ │
│  │       `無効なフレームワーク: ${value}`,               │ │
│  │     'create.missingRequiredArgs':                   │ │
│  │       'CLI引数に必須フィールドが不足しています'      │ │
│  │   }                                                 │ │
│  │ };                                                  │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 2.2 国際化API

```
┌─────────────────────────────────────────────────────────┐
│                    国際化API                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ロケール管理:                                          │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ // ロケール設定                                     │ │
│  │ export function setLocale(                          │ │
│  │   locale: string | undefined                        │ │
│  │ ): void {                                           │ │
│  │   if (locale && SUPPORTED_LOCALES.includes(locale)) {│ │
│  │     currentLocale = locale as SupportedLocale;      │ │
│  │   } else {                                          │ │
│  │     currentLocale = DEFAULT_LOCALE;                 │ │
│  │   }                                                 │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ // 現在のロケール取得                               │ │
│  │ export function getCurrentLocale():                 │ │
│  │   SupportedLocale {                                 │ │
│  │   return currentLocale;                             │ │
│  │ }                                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
│  メッセージ取得:                                        │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ // 基本メッセージ取得                               │ │
│  │ function getMessage(                                │ │
│  │   key: MessageKey,                                  │ │
│  │   params: MessageParams = {}                        │ │
│  │ ): string {                                         │ │
│  │   const messages = messageMap[currentLocale];       │ │
│  │   const message = messages[key];                    │ │
│  │                                                     │ │
│  │   if (typeof message === 'function') {              │ │
│  │     return message(params);                         │ │
│  │   }                                                 │ │
│  │   return message || key;                            │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ // CLIヘルパー関数群                                │ │
│  │ export function getCliDescription(): string {       │ │
│  │   return getMessage('cli.description');             │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ export function formatInvalidOption(                │ │
│  │   option: string, value: string                     │ │
│  │ ): string {                                         │ │
│  │   return getMessage(`create.invalid${option}`, {    │ │
│  │     value                                           │ │
│  │   });                                               │ │
│  │ }                                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

## 3. ファイル操作ユーティリティ

### 3.1 テンプレート処理システム

```
┌─────────────────────────────────────────────────────────┐
│               テンプレート処理システム                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  template-reader.ts:                                    │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ // 基本テンプレート読み込み                         │ │
│  │ export async function readTemplate(                 │ │
│  │   templatePath: string                              │ │
│  │ ): Promise<string> {                                │ │
│  │   const fullPath = path.join(                       │ │
│  │     getTemplatesDirectory(),                        │ │
│  │     templatePath                                    │ │
│  │   );                                                │ │
│  │                                                     │ │
│  │   if (!await fs.pathExists(fullPath)) {             │ │
│  │     throw new Error(                                │ │
│  │       `Template not found: ${templatePath}`         │ │
│  │     );                                              │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   return await fs.readFile(fullPath, 'utf-8');      │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ // 変数置換付きテンプレート読み込み                 │ │
│  │ export async function readTemplateWithReplacements( │ │
│  │   templatePath: string,                             │ │
│  │   replacements: Record<string, any>                 │ │
│  │ ): Promise<string> {                                │ │
│  │   const content = await readTemplate(templatePath); │ │
│  │                                                     │ │
│  │   return content.replace(                           │ │
│  │     /\{\{([^}]+)\}\}/g,                             │ │
│  │     (match, key) => {                               │ │
│  │       const value = replacements[key.trim()];       │ │
│  │       return value !== undefined ? String(value)    │ │
│  │                                  : match;           │ │
│  │     }                                               │ │
│  │   );                                                │ │
│  │ }                                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
│  変数置換パターン:                                      │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ ├ {{PROJECT_NAME}}          # プロジェクト名        │ │
│  │ ├ {{PROJECT_NAME_KEBAB}}    # ケバブケース名        │ │
│  │ ├ {{PROJECT_NAME_SNAKE}}    # スネークケース名      │ │
│  │ ├ {{FRAMEWORK}}             # フレームワーク名      │ │
│  │ ├ {{DATABASE_TYPE}}         # データベース種別      │ │
│  │ ├ {{ORM_TYPE}}              # ORM種別               │ │
│  │ ├ {{AUTH_PROVIDER}}         # 認証プロバイダー      │ │
│  │ └ {{STORAGE_PROVIDER}}      # ストレージプロバイダ  │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 3.2 ファイル生成ユーティリティ

```
┌─────────────────────────────────────────────────────────┐
│               ファイル生成ユーティリティ                 │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  file-generation.ts:                                    │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ // 単一ファイル生成                                 │ │
│  │ export async function generateFile(                 │ │
│  │   outputPath: string,                               │ │
│  │   content: string,                                  │ │
│  │   options: {                                        │ │
│  │     overwrite?: boolean;                            │ │
│  │     encoding?: BufferEncoding;                      │ │
│  │     mode?: number;                                  │ │
│  │   } = {}                                            │ │
│  │ ): Promise<void> {                                  │ │
│  │   const { overwrite = true, encoding = 'utf-8',     │ │
│  │           mode } = options;                         │ │
│  │                                                     │ │
│  │   // 既存ファイルの上書き確認                       │ │
│  │   if (!overwrite && await fs.pathExists(outputPath)) {│ │
│  │     throw new FileExistsError(outputPath);          │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   // ディレクトリ作成                               │ │
│  │   await fs.ensureDir(path.dirname(outputPath));     │ │
│  │                                                     │ │
│  │   // ファイル書き込み                               │ │
│  │   await fs.writeFile(outputPath, content, encoding);│ │
│  │                                                     │ │
│  │   // ファイル権限設定                               │ │
│  │   if (mode !== undefined) {                         │ │
│  │     await fs.chmod(outputPath, mode);               │ │
│  │   }                                                 │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ // バッチファイル生成                               │ │
│  │ export async function generateFiles(                │ │
│  │   files: Array<{                                    │ │
│  │     path: string;                                   │ │
│  │     content: string;                                │ │
│  │     options?: FileGenerationOptions;                │ │
│  │   }>                                                │ │
│  │ ): Promise<void> {                                  │ │
│  │   await Promise.all(                                │ │
│  │     files.map(({ path, content, options }) =>      │ │
│  │       generateFile(path, content, options)          │ │
│  │     )                                               │ │
│  │   );                                                │ │
│  │ }                                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
│  package-json.ts:                                       │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ // package.json生成・操作                           │ │
│  │ export async function generatePackageJson(          │ │
│  │   config: ProjectConfig,                            │ │
│  │   framework: string                                 │ │
│  │ ): Promise<PackageJsonStructure> {                  │ │
│  │   const frameworkConfig =                           │ │
│  │     getFrameworkConfig(framework);                  │ │
│  │                                                     │ │
│  │   const packageJson = {                             │ │
│  │     name: slugify(config.projectName),              │ │
│  │     version: '0.1.0',                               │ │
│  │     private: true,                                  │ │
│  │     scripts: frameworkConfig.scripts,               │ │
│  │     dependencies: mergeDependencies([               │ │
│  │       frameworkConfig.dependencies,                 │ │
│  │       getDatabaseDependencies(config),              │ │
│  │       getAuthDependencies(config),                  │ │
│  │       getStorageDependencies(config)                │ │
│  │     ]),                                             │ │
│  │     devDependencies: frameworkConfig.devDependencies│ │
│  │   };                                                │ │
│  │                                                     │ │
│  │   await generateFile(                               │ │
│  │     path.join(config.projectPath, 'package.json'),  │ │
│  │     JSON.stringify(packageJson, null, 2)            │ │
│  │   );                                                │ │
│  │                                                     │ │
│  │   return packageJson;                               │ │
│  │ }                                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

## 4. プロジェクト構造管理

### 4.1 プロジェクト構造ユーティリティ

```
┌─────────────────────────────────────────────────────────┐
│             プロジェクト構造ユーティリティ               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  project-structure.ts:                                  │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ // ディレクトリ構造作成                             │ │
│  │ export async function createDirectoryStructure(     │ │
│  │   basePath: string,                                 │ │
│  │   structure: DirectoryStructure                     │ │
│  │ ): Promise<void> {                                  │ │
│  │   for (const [name, content] of                     │ │
│  │        Object.entries(structure)) {                 │ │
│  │     const fullPath = path.join(basePath, name);     │ │
│  │                                                     │ │
│  │     if (typeof content === 'object') {              │ │
│  │       // サブディレクトリの再帰作成                 │ │
│  │       await fs.ensureDir(fullPath);                 │ │
│  │       await createDirectoryStructure(fullPath,      │ │
│  │                                      content);      │ │
│  │     } else if (content === null) {                  │ │
│  │       // 空ディレクトリの作成                       │ │
│  │       await fs.ensureDir(fullPath);                 │ │
│  │     } else {                                        │ │
│  │       // ファイルの作成                             │ │
│  │       await generateFile(fullPath, content);        │ │
│  │     }                                               │ │
│  │   }                                                 │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ // プロジェクトファイル検証                         │ │
│  │ export async function validateProjectStructure(     │ │
│  │   projectPath: string,                              │ │
│  │   requiredFiles: string[]                           │ │
│  │ ): Promise<ValidationResult> {                      │ │
│  │   const missing: string[] = [];                     │ │
│  │   const errors: string[] = [];                      │ │
│  │                                                     │ │
│  │   for (const file of requiredFiles) {               │ │
│  │     const filePath = path.join(projectPath, file);  │ │
│  │                                                     │ │
│  │     if (!await fs.pathExists(filePath)) {           │ │
│  │       missing.push(file);                           │ │
│  │     } else {                                        │ │
│  │       try {                                         │ │
│  │         await validateFileContent(filePath);        │ │
│  │       } catch (error) {                             │ │
│  │         errors.push(`${file}: ${error.message}`);   │ │
│  │       }                                             │ │
│  │     }                                               │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   return {                                          │ │
│  │     valid: missing.length === 0 && errors.length === 0,│
│  │     missing,                                        │ │
│  │     errors                                          │ │
│  │   };                                                │ │
│  │ }                                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
│  プロジェクト構造型定義:                                │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ type DirectoryStructure = {                         │ │
│  │   [name: string]:                                   │ │
│  │     | string                    // ファイル内容     │ │
│  │     | null                      // 空ディレクトリ   │ │
│  │     | DirectoryStructure;       // サブディレクトリ │ │
│  │ };                                                  │ │
│  │                                                     │ │
│  │ interface ValidationResult {                        │ │
│  │   valid: boolean;                                   │ │
│  │   missing: string[];                                │ │
│  │   errors: string[];                                 │ │
│  │ }                                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

## 5. ロギング・デバッグシステム

### 5.1 ログシステム

```
┌─────────────────────────────────────────────────────────┐
│                   ログシステム                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  logger.ts:                                             │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ // ログレベル定義                                   │ │
│  │ enum LogLevel {                                     │ │
│  │   DEBUG = 0,                                        │ │
│  │   INFO = 1,                                         │ │
│  │   WARN = 2,                                         │ │
│  │   ERROR = 3                                         │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ // ロガー設定インターフェース                       │ │
│  │ interface LoggerConfig {                            │ │
│  │   level: LogLevel;                                  │ │
│  │   enableColors: boolean;                            │ │
│  │   enableTimestamp: boolean;                         │ │
│  │   outputFile?: string;                              │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ // メインロガークラス                               │ │
│  │ class Logger {                                      │ │
│  │   constructor(private config: LoggerConfig) {}      │ │
│  │                                                     │ │
│  │   debug(message: string, meta?: unknown): void {    │ │
│  │     this.log(LogLevel.DEBUG, message, meta);        │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   info(message: string, meta?: unknown): void {     │ │
│  │     this.log(LogLevel.INFO, message, meta);         │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   warn(message: string, meta?: unknown): void {     │ │
│  │     this.log(LogLevel.WARN, message, meta);         │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   error(message: string, meta?: unknown): void {    │ │
│  │     this.log(LogLevel.ERROR, message, meta);        │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   private log(level: LogLevel, message: string,     │ │
│  │              meta?: unknown): void {               │ │
│  │     if (level < this.config.level) return;          │ │
│  │                                                     │ │
│  │     const timestamp = this.config.enableTimestamp   │ │
│  │       ? new Date().toISOString()                    │ │
│  │       : '';                                         │ │
│  │                                                     │ │
│  │     const logEntry = this.formatLogEntry(           │ │
│  │       level, message, meta, timestamp               │ │
│  │     );                                              │ │
│  │                                                     │ │
│  │     this.output(logEntry);                          │ │
│  │   }                                                 │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ // スコープ付きロガー作成                           │ │
│  │ export function createScopedLogger(                 │ │
│  │   scope: string                                     │ │
│  │ ): Logger {                                         │ │
│  │   return new Logger({                               │ │
│  │     level: getLogLevel(),                           │ │
│  │     enableColors: shouldUseColors(),                │ │
│  │     enableTimestamp: true,                          │ │
│  │     scope                                           │ │
│  │   });                                               │ │
│  │ }                                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 5.2 スピナー・プログレス管理

```
┌─────────────────────────────────────────────────────────┐
│             スピナー・プログレス管理                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  spinner-manager.ts:                                    │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ import ora, { Ora } from 'ora';                      │ │
│  │ import chalk from 'chalk';                           │ │
│  │                                                     │ │
│  │ // スピナー管理クラス                               │ │
│  │ export class SpinnerManager {                       │ │
│  │   private spinners = new Map<string, Ora>();        │ │
│  │                                                     │ │
│  │   // スピナー開始                                   │ │
│  │   start(id: string, text: string,                   │ │
│  │         options?: {                                 │ │
│  │           color?: string;                           │ │
│  │           spinner?: string;                         │ │
│  │         }): void {                                  │ │
│  │     if (this.spinners.has(id)) {                    │ │
│  │       this.stop(id);                                │ │
│  │     }                                               │ │
│  │                                                     │ │
│  │     const spinner = ora({                           │ │
│  │       text,                                         │ │
│  │       color: options?.color || 'cyan',              │ │
│  │       spinner: options?.spinner                     │ │
│  │     }).start();                                     │ │
│  │                                                     │ │
│  │     this.spinners.set(id, spinner);                 │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   // テキスト更新                                   │ │
│  │   updateText(id: string, text: string): void {      │ │
│  │     const spinner = this.spinners.get(id);          │ │
│  │     if (spinner) {                                  │ │
│  │       spinner.text = text;                          │ │
│  │     }                                               │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   // 成功で終了                                     │ │
│  │   succeed(id: string, text?: string): void {        │ │
│  │     const spinner = this.spinners.get(id);          │ │
│  │     if (spinner) {                                  │ │
│  │       spinner.succeed(text);                        │ │
│  │       this.spinners.delete(id);                     │ │
│  │     }                                               │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   // 失敗で終了                                     │ │
│  │   fail(id: string, text?: string): void {           │ │
│  │     const spinner = this.spinners.get(id);          │ │
│  │     if (spinner) {                                  │ │
│  │       spinner.fail(text);                           │ │
│  │       this.spinners.delete(id);                     │ │
│  │     }                                               │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   // 全スピナー停止                                 │ │
│  │   stopAll(): void {                                 │ │
│  │     for (const [id, spinner] of this.spinners) {    │ │
│  │       spinner.stop();                               │ │
│  │     }                                               │ │
│  │     this.spinners.clear();                          │ │
│  │   }                                                 │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ // グローバルスピナーマネージャー                   │ │
│  │ export const spinnerManager = new SpinnerManager(); │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

## 6. 文字列・データ処理

### 6.1 文字列処理ユーティリティ

```
┌─────────────────────────────────────────────────────────┐
│               文字列処理ユーティリティ                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  slugify.ts:                                            │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ // 文字列のスラッグ化（URL・ファイル名安全化）       │ │
│  │ export function slugify(                            │ │
│  │   input: string,                                    │ │
│  │   options: {                                        │ │
│  │     separator?: string;                             │ │
│  │     lowercase?: boolean;                            │ │
│  │     strict?: boolean;                               │ │
│  │   } = {}                                            │ │
│  │ ): string {                                         │ │
│  │   const {                                           │ │
│  │     separator = '-',                                │ │
│  │     lowercase = true,                               │ │
│  │     strict = true                                   │ │
│  │   } = options;                                      │ │
│  │                                                     │ │
│  │   let result = input.trim();                        │ │
│  │                                                     │ │
│  │   // Unicode正規化                                  │ │
│  │   result = result.normalize('NFD');                 │ │
│  │                                                     │ │
│  │   // 特殊文字・アクセント記号の除去                 │ │
│  │   result = result.replace(/[\u0300-\u036f]/g, '');  │ │
│  │                                                     │ │
│  │   // 小文字変換                                     │ │
│  │   if (lowercase) {                                  │ │
│  │     result = result.toLowerCase();                  │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   if (strict) {                                     │ │
│  │     // 英数字以外を区切り文字に置換                 │ │
│  │     result = result.replace(/[^a-z0-9]/g, separator);│ │
│  │   } else {                                          │ │
│  │     // スペースのみを区切り文字に置換               │ │
│  │     result = result.replace(/\s+/g, separator);     │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   // 連続する区切り文字を単一に                     │ │
│  │   const escapedSeparator = separator.replace(       │ │
│  │     /[.*+?^${}()|[\]\\]/g, '\\$&'                   │ │
│  │   );                                                │ │
│  │   const regex = new RegExp(                         │ │
│  │     `${escapedSeparator}+`, 'g'                     │ │
│  │   );                                                │ │
│  │   result = result.replace(regex, separator);        │ │
│  │                                                     │ │
│  │   // 前後の区切り文字を除去                         │ │
│  │   const trimRegex = new RegExp(                     │ │
│  │     `^${escapedSeparator}+|${escapedSeparator}+$`,  │ │
│  │     'g'                                             │ │
│  │   );                                                │ │
│  │   result = result.replace(trimRegex, '');           │ │
│  │                                                     │ │
│  │   return result;                                    │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ // ケース変換ヘルパー                               │ │
│  │ export function toKebabCase(str: string): string {  │ │
│  │   return slugify(str, { separator: '-' });          │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ export function toSnakeCase(str: string): string {  │ │
│  │   return slugify(str, { separator: '_' });          │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ export function toCamelCase(str: string): string {  │ │
│  │   return slugify(str, { separator: '-' })           │ │
│  │     .replace(/-([a-z])/g, (_, char) =>              │ │
│  │       char.toUpperCase());                          │ │
│  │ }                                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

## 7. 外部統合・クラウドユーティリティ

### 7.1 クラウドプロビジョニング

```
┌─────────────────────────────────────────────────────────┐
│             クラウドプロビジョニング                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  cloud/cli-provisioner.ts:                              │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ // CLI経由でのクラウドリソース管理                   │ │
│  │ export class CLIProvisioner implements              │ │
│  │                        CloudProvisioner {           │ │
│  │   async provisionDatabase(                          │ │
│  │     config: DatabaseProvisionConfig                 │ │
│  │   ): Promise<ProvisionResult> {                     │ │
│  │     switch (config.type) {                          │ │
│  │       case 'turso':                                 │ │
│  │         return await this.provisionTurso(config);   │ │
│  │       case 'supabase':                              │ │
│  │         return await this.provisionSupabase(config);│ │
│  │       default:                                      │ │
│  │         throw new UnsupportedProviderError(         │ │
│  │           config.type                               │ │
│  │         );                                          │ │
│  │     }                                               │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   private async provisionTurso(                     │ │
│  │     config: TursoConfig                             │ │
│  │   ): Promise<ProvisionResult> {                     │ │
│  │     // Turso CLI実行                                │ │
│  │     const result = await execa('turso', [           │ │
│  │       'db', 'create', config.databaseName,          │ │
│  │       '--group', config.group || 'default'          │ │
│  │     ]);                                             │ │
│  │                                                     │ │
│  │     if (result.exitCode !== 0) {                    │ │
│  │       throw new ProvisioningError(                  │ │
│  │         'Turso database creation failed',           │ │
│  │         result.stderr                               │ │
│  │       );                                            │ │
│  │     }                                               │ │
│  │                                                     │ │
│  │     // 接続情報取得                                 │ │
│  │     const urlResult = await execa('turso', [        │ │
│  │       'db', 'show', config.databaseName, '--url'    │ │
│  │     ]);                                             │ │
│  │                                                     │ │
│  │     return {                                        │ │
│  │       success: true,                                │ │
│  │       connectionString: urlResult.stdout.trim(),    │ │
│  │       metadata: {                                   │ │
│  │         provider: 'turso',                          │ │
│  │         databaseName: config.databaseName           │ │
│  │       }                                             │ │
│  │     };                                              │ │
│  │   }                                                 │ │
│  │ }                                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
│  cloud/mock-provisioner.ts:                            │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ // テスト用モックプロビジョナー                     │ │
│  │ export class MockProvisioner implements             │ │
│  │                        CloudProvisioner {           │ │
│  │   async provisionDatabase(                          │ │
│  │     config: DatabaseProvisionConfig                 │ │
│  │   ): Promise<ProvisionResult> {                     │ │
│  │     // モック実装 - テスト用ダミーデータ           │ │
│  │     await new Promise(resolve =>                     │ │
│  │       setTimeout(resolve, 100));                    │ │
│  │                                                     │ │
│  │     return {                                        │ │
│  │       success: true,                                │ │
│  │       connectionString: `mock://${config.type}/     │ │
│  │                         ${config.databaseName}`,    │ │
│  │       metadata: {                                   │ │
│  │         provider: config.type,                      │ │
│  │         databaseName: config.databaseName,          │ │
│  │         mock: true                                  │ │
│  │       }                                             │ │
│  │     };                                              │ │
│  │   }                                                 │ │
│  │ }                                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 7.2 ダウンロード・HTTP ユーティリティ

```
┌─────────────────────────────────────────────────────────┐
│             ダウンロード・HTTPユーティリティ            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  download.ts:                                           │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ import { createWriteStream } from 'fs';              │ │
│  │ import { pipeline } from 'stream/promises';          │ │
│  │                                                     │ │
│  │ // ファイルダウンロード機能                         │ │
│  │ export async function downloadFile(                 │ │
│  │   url: string,                                      │ │
│  │   outputPath: string,                               │ │
│  │   options: {                                        │ │
│  │     headers?: Record<string, string>;               │ │
│  │     timeout?: number;                               │ │
│  │     onProgress?: (progress: DownloadProgress) =>    │ │
│  │                   void;                             │ │
│  │   } = {}                                            │ │
│  │ ): Promise<DownloadResult> {                        │ │
│  │   const controller = new AbortController();         │ │
│  │   const { headers = {}, timeout = 30000 } = options;│ │
│  │                                                     │ │
│  │   // タイムアウト設定                               │ │
│  │   const timeoutId = setTimeout(() => {              │ │
│  │     controller.abort();                             │ │
│  │   }, timeout);                                      │ │
│  │                                                     │ │
│  │   try {                                             │ │
│  │     const response = await fetch(url, {             │ │
│  │       headers,                                      │ │
│  │       signal: controller.signal                     │ │
│  │     });                                             │ │
│  │                                                     │ │
│  │     if (!response.ok) {                             │ │
│  │       throw new DownloadError(                      │ │
│  │         `HTTP ${response.status}: ${response.statusText}`│
│  │       );                                            │ │
│  │     }                                               │ │
│  │                                                     │ │
│  │     const contentLength = parseInt(                 │ │
│  │       response.headers.get('content-length') || '0' │ │
│  │     );                                              │ │
│  │                                                     │ │
│  │     // プログレス付きダウンロード                   │ │
│  │     if (options.onProgress && contentLength > 0) {  │ │
│  │       const progressStream = new ProgressStream(    │ │
│  │         contentLength, options.onProgress           │ │
│  │       );                                            │ │
│  │                                                     │ │
│  │       await pipeline(                               │ │
│  │         response.body!,                             │ │
│  │         progressStream,                             │ │
│  │         createWriteStream(outputPath)               │ │
│  │       );                                            │ │
│  │     } else {                                        │ │
│  │       await pipeline(                               │ │
│  │         response.body!,                             │ │
│  │         createWriteStream(outputPath)               │ │
│  │       );                                            │ │
│  │     }                                               │ │
│  │                                                     │ │
│  │     return {                                        │ │
│  │       success: true,                                │ │
│  │       filePath: outputPath,                         │ │
│  │       size: contentLength                           │ │
│  │     };                                              │ │
│  │                                                     │ │
│  │   } finally {                                       │ │
│  │     clearTimeout(timeoutId);                        │ │
│  │   }                                                 │ │
│  │ }                                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

## 8. 環境・設定管理

### 8.1 環境変数ファイル管理

```
┌─────────────────────────────────────────────────────────┐
│               環境変数ファイル管理                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  env-file.ts:                                           │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ // .env ファイル生成・管理                          │ │
│  │ export interface EnvVariable {                      │ │
│  │   key: string;                                      │ │
│  │   value?: string;                                   │ │
│  │   comment?: string;                                 │ │
│  │   required?: boolean;                               │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ export async function generateEnvFile(              │ │
│  │   outputPath: string,                               │ │
│  │   variables: EnvVariable[]                          │ │
│  │ ): Promise<void> {                                  │ │
│  │   const lines: string[] = [];                       │ │
│  │                                                     │ │
│  │   // ヘッダーコメント                               │ │
│  │   lines.push('# Environment Variables');            │ │
│  │   lines.push('# Generated by Fluorite-flake');      │ │
│  │   lines.push('');                                   │ │
│  │                                                     │ │
│  │   for (const variable of variables) {               │ │
│  │     // コメント追加                                 │ │
│  │     if (variable.comment) {                         │ │
│  │       lines.push(`# ${variable.comment}`);          │ │
│  │     }                                               │ │
│  │                                                     │ │
│  │     // 必須マーカー                                 │ │
│  │     if (variable.required) {                        │ │
│  │       lines.push('# Required');                     │ │
│  │     }                                               │ │
│  │                                                     │ │
│  │     // 環境変数定義                                 │ │
│  │     const value = variable.value || '';             │ │
│  │     lines.push(`${variable.key}=${value}`);         │ │
│  │     lines.push('');                                 │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   await generateFile(outputPath, lines.join('\n')); │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ // 設定別環境変数生成                               │ │
│  │ export function getDatabaseEnvVariables(            │ │
│  │   config: ProjectConfig                             │ │
│  │ ): EnvVariable[] {                                  │ │
│  │   const variables: EnvVariable[] = [];              │ │
│  │                                                     │ │
│  │   switch (config.database) {                        │ │
│  │     case 'turso':                                   │ │
│  │       variables.push(                               │ │
│  │         {                                           │ │
│  │           key: 'TURSO_DATABASE_URL',                │ │
│  │           comment: 'Turso database connection URL', │ │
│  │           required: true                            │ │
│  │         },                                          │ │
│  │         {                                           │ │
│  │           key: 'TURSO_AUTH_TOKEN',                  │ │
│  │           comment: 'Turso authentication token',    │ │
│  │           required: true                            │ │
│  │         }                                           │ │
│  │       );                                            │ │
│  │       break;                                        │ │
│  │                                                     │ │
│  │     case 'supabase':                                │ │
│  │       variables.push(                               │ │
│  │         {                                           │ │
│  │           key: 'DATABASE_URL',                      │ │
│  │           comment: 'Supabase Postgres connection',  │ │
│  │           required: true                            │ │
│  │         },                                          │ │
│  │         {                                           │ │
│  │           key: 'NEXT_PUBLIC_SUPABASE_URL',          │ │
│  │           comment: 'Supabase project URL',          │ │
│  │           required: true                            │ │
│  │         },                                          │ │
│  │         {                                           │ │
│  │           key: 'NEXT_PUBLIC_SUPABASE_ANON_KEY',     │ │
│  │           comment: 'Supabase anonymous key',        │ │
│  │           required: true                            │ │
│  │         }                                           │ │
│  │       );                                            │ │
│  │       break;                                        │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   return variables;                                 │ │
│  │ }                                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

## 9. エラーハンドリング・型定義

### 9.1 エラー型システム

```
┌─────────────────────────────────────────────────────────┐
│                 エラー型システム                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  error-types.ts:                                        │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ // ベースエラークラス                               │ │
│  │ export abstract class FluoriteError extends Error { │ │
│  │   abstract readonly code: string;                   │ │
│  │   abstract readonly category: ErrorCategory;        │ │
│  │                                                     │ │
│  │   constructor(                                      │ │
│  │     message: string,                                │ │
│  │     public readonly context?: Record<string, any>   │ │
│  │   ) {                                               │ │
│  │     super(message);                                 │ │
│  │     this.name = this.constructor.name;              │ │
│  │   }                                                 │ │
│  │                                                     │ │
│  │   toJSON() {                                        │ │
│  │     return {                                        │ │
│  │       name: this.name,                              │ │
│  │       message: this.message,                        │ │
│  │       code: this.code,                              │ │
│  │       category: this.category,                      │ │
│  │       context: this.context,                        │ │
│  │       stack: this.stack                             │ │
│  │     };                                              │ │
│  │   }                                                 │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ // エラーカテゴリ定義                               │ │
│  │ export enum ErrorCategory {                         │ │
│  │   VALIDATION = 'validation',                        │ │
│  │   FILE_SYSTEM = 'file_system',                      │ │
│  │   NETWORK = 'network',                              │ │
│  │   EXTERNAL_SERVICE = 'external_service',            │ │
│  │   GENERATION = 'generation',                        │ │
│  │   CONFIGURATION = 'configuration'                   │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ // 具体的エラークラス群                             │ │
│  │ export class ValidationError extends FluoriteError {│ │
│  │   readonly code = 'VALIDATION_ERROR';               │ │
│  │   readonly category = ErrorCategory.VALIDATION;     │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ export class FileExistsError extends FluoriteError {│ │
│  │   readonly code = 'FILE_EXISTS';                    │ │
│  │   readonly category = ErrorCategory.FILE_SYSTEM;    │ │
│  │                                                     │ │
│  │   constructor(filePath: string) {                   │ │
│  │     super(`File already exists: ${filePath}`, {     │ │
│  │       filePath                                      │ │
│  │     });                                             │ │
│  │   }                                                 │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ export class TemplateNotFoundError extends         │ │
│  │                          FluoriteError {            │ │
│  │   readonly code = 'TEMPLATE_NOT_FOUND';             │ │
│  │   readonly category = ErrorCategory.FILE_SYSTEM;    │ │
│  │                                                     │ │
│  │   constructor(templatePath: string) {               │ │
│  │     super(`Template not found: ${templatePath}`, {  │ │
│  │       templatePath                                  │ │
│  │     });                                             │ │
│  │   }                                                 │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ export class NetworkError extends FluoriteError {   │ │
│  │   readonly code = 'NETWORK_ERROR';                  │ │
│  │   readonly category = ErrorCategory.NETWORK;        │ │
│  │ }                                                   │ │
│  │                                                     │ │
│  │ export class GenerationError extends FluoriteError {│ │
│  │   readonly code = 'GENERATION_ERROR';               │ │
│  │   readonly category = ErrorCategory.GENERATION;     │ │
│  │ }                                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

## 10. ユーティリティベストプラクティス

### 10.1 設計原則・使用ガイドライン

```
┌─────────────────────────────────────────────────────────┐
│             ユーティリティ設計原則                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 単一責任原則                                        │
│     ├ 各ユーティリティは明確な単一機能を提供           │
│     ├ 責任範囲を限定し、予測可能な動作を保証           │
│     └ 機能拡張時は新しいモジュールとして分離           │
│                                                         │
│  2. 型安全性の確保                                      │
│     ├ TypeScript型システムを最大限活用                 │
│     ├ ジェネリクスによる型安全な汎用関数               │
│     └ ランタイム型チェックによる防御的プログラミング   │
│                                                         │
│  3. エラーハンドリング                                  │
│     ├ 予測可能なエラー型の提供                         │
│     ├ 詳細なコンテキスト情報の保持                     │
│     └ 回復可能・不可能エラーの明確な区別               │
│                                                         │
│  4. テスタビリティ                                      │
│     ├ 純粋関数としての実装を優先                       │
│     ├ 依存性注入による疎結合設計                       │
│     └ モック・スタブ対応インターフェース               │
│                                                         │
│  5. パフォーマンス                                      │
│     ├ 適切なキャッシング戦略                           │
│     ├ 非同期処理による応答性向上                       │
│     └ メモリリークの防止                               │
│                                                         │
│  6. 拡張性                                              │
│     ├ プラグイン機能による機能拡張                     │
│     ├ 設定による動作カスタマイズ                       │
│     └ 後方互換性の維持                                 │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 10.2 使用例・統合パターン

```typescript
┌─────────────────────────────────────────────────────────┐
│              使用例・統合パターン                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  // 統合例：プロジェクト生成での活用                    │
│  export async function generateProject(                 │
│    config: ProjectConfig                                │
│  ): Promise<void> {                                     │
│    const logger = createScopedLogger('generator');      │
│    const spinner = spinnerManager;                      │
│                                                         │
│    try {                                                │
│      // 1. 設定検証                                     │
│      validateProjectConfig(config);                     │
│                                                         │
│      // 2. プロジェクト名処理                           │
│      const projectSlug = slugify(config.projectName);   │
│                                                         │
│      // 3. 進捗表示開始                                 │
│      spinner.start('generation',                        │
│        getMessage('generation.starting'));              │
│                                                         │
│      // 4. ディレクトリ構造作成                         │
│      await createDirectoryStructure(                    │
│        config.projectPath,                              │
│        getFrameworkStructure(config.framework)          │
│      );                                                 │
│                                                         │
│      // 5. テンプレートファイル生成                     │
│      const templateData = {                             │
│        PROJECT_NAME: config.projectName,                │
│        PROJECT_NAME_KEBAB: projectSlug,                 │
│        FRAMEWORK: config.framework                      │
│      };                                                 │
│                                                         │
│      const templates = getRequiredTemplates(config);    │
│      for (const template of templates) {                │
│        const content = await readTemplateWithReplacements(│
│          template.path, templateData                    │
│        );                                               │
│        await generateFile(template.output, content);    │
│      }                                                  │
│                                                         │
│      // 6. 環境変数ファイル生成                         │
│      const envVariables = [                             │
│        ...getDatabaseEnvVariables(config),              │
│        ...getAuthEnvVariables(config),                  │
│        ...getStorageEnvVariables(config)                │
│      ];                                                 │
│      await generateEnvFile(                             │
│        path.join(config.projectPath, '.env.example'),   │
│        envVariables                                     │
│      );                                                 │
│                                                         │
│      // 7. 成功完了                                     │
│      spinner.succeed('generation',                      │
│        getMessage('generation.completed'));             │
│      logger.info('Project generation completed',        │
│                  { projectPath: config.projectPath });  │
│                                                         │
│    } catch (error) {                                    │
│      spinner.fail('generation',                         │
│        getMessage('generation.failed'));                │
│      logger.error('Project generation failed', error);  │
│      throw error;                                       │
│    }                                                    │
│  }                                                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

*次章: [07_デプロイメント](./07_デプロイメント.md)*
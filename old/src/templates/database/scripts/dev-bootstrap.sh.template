#!/usr/bin/env node
import { spawn } from 'node:child_process';
import { fileURLToPath } from 'node:url';
import path from 'node:path';
import fs from 'node:fs/promises';

const __filename = fileURLToPath(import.meta.url);
const scriptDir = path.dirname(__filename);
const projectRoot = path.resolve(scriptDir, '..');

function run(command, options = {}) {
  return new Promise((resolve, reject) => {
    const child = spawn(command, {
      stdio: 'inherit',
      shell: true,
      ...options,
    });

    child.on('exit', (code) => (code === 0 ? resolve() : reject(new Error('Command failed: ' + command))));
  });
}

async function fileExists(target) {
  try {
    await fs.access(target);
    return true;
  } catch {
    return false;
  }
}

async function ensureDatabase() {
  const initScript = path.join(scriptDir, 'init-turso-db.sh');
  const sentinel = path.join(projectRoot, '.fluorite-db-ready');
  const dbFile = path.join(projectRoot, 'prisma/dev.db');
  const force = process.env.FORCE_DB_INIT === '1';

  const needsInit = force || !(await fileExists(sentinel)) || !(await fileExists(dbFile));

  if (!needsInit) {
    return;
  }

  try {
    await fs.access(initScript);
    await run('bash "' + initScript + '"', { cwd: projectRoot });
  } catch {
    // Optional for non-Turso setups
  }
}

const extraArgs = process.argv.slice(2);

try {
  await ensureDatabase();

  const pkg = JSON.parse(await fs.readFile(path.join(projectRoot, 'package.json'), 'utf-8'));
  const baseCommand = pkg.scripts?.['dev:next'] ?? 'next dev';
  const command = [baseCommand, ...extraArgs].filter(Boolean).join(' ');

  await run(command, { cwd: projectRoot });
} catch (error) {
  console.error(error.message);
  process.exit(1);
}
